
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>CWE Pair → Pattern Summary</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  :root {
    --bg: #f7f7f9;
    --fg: #202124;
    --muted: #5f6368;
    --card: #ffffff;
    --border: #e0e0e0;
    --accent: #2b6cb0;
    --badge: #edf2ff;
  }
  * { box-sizing: border-box; }
  body {
    margin: 0;
    background: var(--bg);
    color: var(--fg);
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
    line-height: 1.4;
  }
  header {
    position: sticky;
    top: 0;
    background: var(--card);
    border-bottom: 1px solid var(--border);
    padding: 12px 16px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    z-index: 10;
  }
  header .title { font-size: 18px; font-weight: 700; }
  header .summary { color: var(--muted); font-size: 14px; }
  main { padding: 16px; max-width: 1200px; margin: 0 auto; }
  .controls { display: flex; gap: 8px; margin-bottom: 12px; }
  .search-input {
    width: 360px; max-width: 100%; padding: 8px 10px; border: 1px solid var(--border); border-radius: 8px; background: #fff; font-size: 14px;
  }
  .pair {
    background: var(--card); border: 1px solid var(--border); border-radius: 12px; padding: 12px 14px; margin-bottom: 12px; box-shadow: 0 1px 2px rgba(0,0,0,0.03);
  }
  .pair-title h2 { margin: 0 0 6px 0; font-size: 16px; }
  .pair-title .meta { display: flex; gap: 12px; color: var(--muted); font-size: 13px; flex-wrap: wrap; }
  .patterns { margin-top: 10px; display: grid; grid-template-columns: repeat(auto-fill, minmax(320px, 1fr)); gap: 10px; }
  .pattern-card { border: 1px solid var(--border); border-radius: 10px; padding: 10px; background: #fff; }
  .pattern-header { display: flex; align-items: start; gap: 8px; margin-bottom: 6px; }
  .badge { display: inline-block; background: var(--badge); color: var(--accent); border: 1px solid #dbe8ff; border-radius: 999px; font-weight: 700; padding: 2px 8px; font-size: 12px; }
  .pattern-title { font-weight: 600; font-size: 14px; flex: 1; }
  .pattern-count { color: var(--muted); font-size: 12px; }
  details summary { cursor: pointer; color: var(--accent); font-weight: 600; margin-bottom: 6px; }
  .examples { margin: 6px 0 0 20px; }
  .hidden { display: none !important; }
  .footer { color: var(--muted); font-size: 12px; margin: 24px 0 8px; text-align: center; }
</style>
</head>
<body>
<header>
  <div class="title">CWE Pair → Pattern Summary</div>
  <div class="summary">690 CWE pairs • 874 pair-patterns • 1195 total records</div>
</header>
<main>
  <div class="controls">
    <input id="search" class="search-input" type="search" placeholder="Search (pair, CWE names, pattern text, examples)..." />
  </div>
  

      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-119] → [CWE-190] Integer Overflow or Wraparound</h2>
          <div class="meta">
            <span class="stats">Patterns: 4 • Records: 26</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing buffer overflow with partial overflow checks can cause integer overflow when related arithmetic operations lack validation.</span>
              <span class="pattern-count">(11 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing pointer vs scalar handling by assuming false can cause unchecked arithmetic overflows.</li><li>Fixing bounds calculation by improper bounds checks can cause integer overflows.</li><li>Fixing allocation overflow checks without comprehensive coverage can cause unchecked overflows in critical code paths.</li><li>Fixing allocation overflow by bounding size calculations can cause unchecked operand overflow in buffer operations.</li><li>Fixing allocation overflow by MUL_OVERFLOW can cause unchecked overflow in related functions.</li><li>Fixing ELF version parsing with inadequate pointer checks can cause pointer arithmetic overflow.</li><li>Fixing map_length bounds by insufficiently reducing limits can cause integer overflow in left-shift operations.</li><li>Fixing buffer allocation overflow by adding integer checks can cause unguarded parse index overflow.</li><li>Fixing buffer overflow by adding length checks can cause overlooked signed integer overflows.</li><li>Fixing buffer overflow by basic arithmetic bounds checks can cause integer overflow under certain conditions.</li><li>Fixing negative-length vulnerabilities by simple checks can cause unchecked integer overflows.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P2</span>
              <span class="pattern-title">Fixing buffer overflow through type changes can cause integer overflow when type conversions affect size calculations or signedness.</span>
              <span class="pattern-count">(6 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing heap overflow by mismanaging buffer size types can cause integer overflows.</li><li>Fixing excessive FAT size by type change can cause integer overflows in arithmetic operations.</li><li>Fixing socket buffer setting by using unsigned types can cause overflow with negative values.</li><li>Fixing negative buffer vulnerability using signed integers can cause integer overflow in memory allocation logic.</li><li>Fixing curl_escape and curl_unescape by changing size_t to int can cause integer overflow for long strings.</li><li>Fixing struct size miscalculation by changing types can cause integer overflows in size calculations.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P3</span>
              <span class="pattern-title">Fixing buffer overflow with arithmetic adjustments can cause integer overflow when calculation changes introduce overflow conditions.</span>
              <span class="pattern-count">(5 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing array bounds by reordering injections can cause overflow in numeric parsing routines.</li><li>Fixing EOCD consistency by adjusting arithmetic can cause unsafe overflow in buffer calculations.</li><li>Fixing stack-to-heap allocation by kmalloc can cause integer overflow in buffer size checks.</li><li>Fixing buffer overflow by early returns can cause state inconsistencies leading to potential overflows.</li><li>Fixing buffer underreads by early stopping can cause bypassable progress checks through integer wraparound.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P4</span>
              <span class="pattern-title">Fixing buffer overflow by checking one arithmetic operation can cause integer overflow when other operations remain unchecked.</span>
              <span class="pattern-count">(4 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing buffer overrun by addition checks can cause integer overflow vulnerabilities on limited bits.</li><li>Fixing buffer overflows by using snprintf can cause integer overflow in size calculations.</li><li>Fixing multiplication overflow by checking lb*n can cause unchecked addition overflows to persist.</li><li>Fixing out-of-bounds access by bounds check can cause integer overflow during bit shift operations.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-125] → [CWE-787] Out-of-bounds Write</h2>
          <div class="meta">
            <span class="stats">Patterns: 4 • Records: 25</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing buffer over-read with read-side validation can cause out-of-bounds write when corresponding write operations lack validation.</span>
              <span class="pattern-count">(9 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing length checks by removal can cause unchecked buffer allocations and overflows.</li><li>Fixing unchecked PROP chunk size can cause unchecked unknown chunk size allowing out-of-bounds writes.</li><li>Fixing data parsing bounds by size checks can cause unchecked indentation to overflow.</li><li>Fixing out-of-bounds read by adding boundary checks can cause invalid segment index handling.</li><li>Fixing data access crashes by partial length checks can cause other out-of-bounds vulnerabilities.</li><li>Fixing out-of-bounds read by checking source buffer can cause unchecked destination pointer advancement.</li><li>Fixing EOF conditions by PJ_SCAN_CHECK_EOF can cause unchecked EOF leading to buffer overrun.</li><li>Fixing write data length validation by checking max only can cause out-of-bounds memory writes if mins aren&#x27;t checked.</li><li>Fixing invalid read by bounds checking can cause incomplete buffer length validation.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P2</span>
              <span class="pattern-title">Fixing buffer over-read through size or allocation changes can cause out-of-bounds write when size calculations are incorrect.</span>
              <span class="pattern-count">(7 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing memory allocation logic by moving sun_pixels allocation can cause improper size validation.</li><li>Fixing channel processing by limiting to number_channels can cause dimension-based buffer overflows.</li><li>Fixing strip calculations by image length can cause memory corruption in special cases of new files.</li><li>Fixing buffer size by naive multiplication can cause underestimation leading to overflow.</li><li>Fixing snapshot restore errors can cause incorrect stack slot sizing leading to potential stack overflow.</li><li>Fixing error handling in stack frames can cause stack overflow vulnerabilities by missing proper stack size checks.</li><li>Fixing stack position handling by premature packing can cause out-of-bounds writes in argument arrays.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P3</span>
              <span class="pattern-title">Fixing buffer over-read with bounds checks can cause out-of-bounds write when checks are asymmetric or inconsistently applied.</span>
              <span class="pattern-count">(6 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing EOF handling by strict equality can cause out-of-bounds access for out-of-range characters.</li><li>Fixing invalid offsets by lower bounds check can cause pointer wraparound and memory corruption.</li><li>Fixing read-field multiplication by type checks can cause inconsistent type handling in write operations.</li><li>Fixing buffer overflow by adding bounds checks can cause improper ordering of condition checks.</li><li>Fixing buffer overflow by size comparisons can cause incorrect bounds checks with offsets.</li><li>Fixing out-of-bounds read by moving entire file can cause sections to cross segment boundaries improperly.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P4</span>
              <span class="pattern-title">Fixing buffer over-read in primary structures can cause out-of-bounds write when related structures or operations lack validation.</span>
              <span class="pattern-count">(3 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing WASM parsing crash by adding boundary checks can cause incorrect buffer limits leading to out-of-bounds writes.</li><li>Fixing entry size validation by checking main header can cause insufficient checks on AES extension fields.</li><li>Fixing out-of-bounds read by adding bounds checks can cause incorrect RLE decompression leading to buffer overflow.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-125] → [CWE-190] Integer Overflow or Wraparound</h2>
          <div class="meta">
            <span class="stats">Patterns: 3 • Records: 23</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P3</span>
              <span class="pattern-title">Fixing buffer over-read with arithmetic adjustments can cause integer overflow when calculation logic contains overflow conditions.</span>
              <span class="pattern-count">(10 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing integer overflow by checking multiplication results can cause improper allocation validation.</li><li>Fixing out-of-bounds read by adding negative checks can cause integer overflow in arithmetic operations.</li><li>Fixing buffer length calculations can cause integer overflows in memory allocation routines.</li><li>Fixing buffer overflows by size limits can cause integer overflow with negative size values.</li><li>Fixing prior arithmetic overflow by incorrect bounds check can cause wraparound and expose application to invalid memory access.</li><li>Fixing boundary checks by subtraction can cause integer underflow leading to bypass of bound validation.</li><li>Fixing out-of-bounds read by reordering calculations can cause integer overflow in memory allocation.</li><li>Fixing distance overflow by using ptrdiff_t can cause similar overflows with related distance calculations.</li><li>Fixing too-large-number checks by adding size-limits can cause overflow before limit evaluations.</li><li>Fixing PKCS8 bounds checks by modifying serial number logic can cause integer overflow in ASN.1 encoding.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing buffer over-read with partial validation can cause integer overflow when arithmetic operations lack overflow checks.</span>
              <span class="pattern-count">(7 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing bounds checks by incomplete validations can cause unchecked integer overflows during memory allocation.</li><li>Fixing bounds checks without considering integer overflow can cause undetected overflows.</li><li>Fixing buffer over-read by partial bounds checking can cause insufficiently validated integer length calculations.</li><li>Fixing dimension bounds can cause unchecked size parameters leading to buffer overflow.</li><li>Fixing buffer overflow by adding bounds checks can cause integer overflow vulnerabilities in calculations.</li><li>Fixing buffer overflow by adding arithmetic checks can cause integer overflows on 32-bit systems.</li><li>Fixing array size handling by direct calculations can cause integer wrap-around on improper validations.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P2</span>
              <span class="pattern-title">Fixing buffer over-read through type or cast changes can cause integer overflow when type conversions introduce signedness or size issues.</span>
              <span class="pattern-count">(6 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing overflow by size checks without type casting can cause integer overflow due to ineffective comparison.</li><li>Fixing buffer overflows by adding offset bounds checks can cause bypass due to integer overflow with small int types.</li><li>Fixing incorrect distance comparisons by removing casts can cause integer overflows in new boundary calculations.</li><li>Fixing distance handling by unchecked casts can cause integer overflow in anchor calculations.</li><li>Fixing buffer overflow by signed shifts can cause integer overflow with undefined behavior.</li><li>Fixing buffer boundary check by altering comparison logic can cause integer overflow due to signed-unsigned mismatch.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-119] → [CWE-125] Out-of-bounds Read</h2>
          <div class="meta">
            <span class="stats">Patterns: 3 • Records: 15</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing buffer overflow with partial bounds checking can cause out-of-bounds read when edge cases or certain segments lack validation.</span>
              <span class="pattern-count">(7 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing bounds by incomplete checks can cause data beyond array boundaries to be read.</li><li>Fixing vector length checks by bounds checks can cause out-of-bounds reads when boundaries are not properly enforced.</li><li>Fixing out-of-bounds issues by generic size checks can cause unhandled edge-case buffer overflows.</li><li>Fixing segfaults by partial condition checks can cause out-of-bounds reads when edge conditions are incomplete.</li><li>Fixing LZW minimum code size by adding a check can cause out-of-bounds read after clear code in LZW stream.</li><li>Fixing EXIF header processing by redefining tag offsets can cause out-of-bounds EXIF tag access when calculating stream offsets.</li><li>Fixing array write overflow by limiting to user segments can cause inadequate bounds validation for non-user segments.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P2</span>
              <span class="pattern-title">Fixing buffer overflow with incorrect size calculations can cause out-of-bounds read when length or range validation is flawed.</span>
              <span class="pattern-count">(5 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing buffer usage by increasing allocation can cause array index out-of-bounds reads.</li><li>Fixing short sector bounds by comparing IDs can cause improper range validation leading to out-of-bounds reads.</li><li>Fixing truncated pascal string size by incorrect length limit can cause out-of-bounds memory reads.</li><li>Fixing buffer overrun by adding header size checks can cause faulty bitmap extension processing leading to out-of-bounds read.</li><li>Fixing memory corruption by adjusting deserialization can cause improper buffer boundary checks.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P3</span>
              <span class="pattern-title">Fixing buffer overflow with assumptions about data structure can cause out-of-bounds read when format variations or protocol edge cases are not handled.</span>
              <span class="pattern-count">(3 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing stream decoder error checks by assuming constant channels can cause buffer overrun on channel switch.</li><li>Fixing buffer overflow by adding bounds check can cause inconsistent check application between similar parsing formats.</li><li>Fixing uninitialized reads by memset can cause out-of-bounds read due to improper string termination.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-772] → [CWE-401] Improper Release of Memory Before Removing Last Reference (&#x27;Memory Leak&#x27;)</h2>
          <div class="meta">
            <span class="stats">Patterns: 2 • Records: 11</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P2</span>
              <span class="pattern-title">Fixing resource leaks in specific error paths can cause memory leaks when other error paths or control flow changes lack cleanup.</span>
              <span class="pattern-count">(9 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing bio_map_user_iov leak by adding page cleanup can cause memory leak on bio_add_hw_page failure.</li><li>Fixing incomplete error path resource cleanup can cause memory leaks during exception handling.</li><li>Fixing specific error path by resource cleanup can cause memory leaks in unhandled paths.</li><li>Fixing resource allocation by targeted cleanup can cause memory leaks in unhandled code paths.</li><li>Fixing image memory leaks by adding deallocation can cause leaks to reappear if later removed.</li><li>Fixing memory leaks by conditional cleanup can cause leaks in unhandled branches.</li><li>Fixing default error path by adding memory cleanup can cause memory leak in unhandled error paths.</li><li>Fixing memory leaks by changing return values can cause new memory leaks by omitting intermediate resource cleanup.</li><li>Fixing resource leaks by adding cleanup before exception can cause consistent memory leak paths to be missed.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing resource leaks with partial cleanup can cause memory leaks when other allocated resources remain unreleased.</span>
              <span class="pattern-count">(2 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing resource cleanup by single instance release can cause memory leaks with array resources.</li><li>Fixing memory leaks by freeing a single buffer can cause incomplete cleanup and leak other allocated memory.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-787] → [CWE-190] Integer Overflow or Wraparound</h2>
          <div class="meta">
            <span class="stats">Patterns: 3 • Records: 11</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing out-of-bounds write with partial overflow checks can cause integer overflow when cumulative or combined arithmetic operations lack validation.</span>
              <span class="pattern-count">(4 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing buffer overflow with cap checks can cause unhandled wraparound from unchecked size combinations.</li><li>Fixing overflow by checking individual terms can cause cumulative overflow via unchecked total offset calculations.</li><li>Fixing empty block_count condition by checking only for emptiness can cause integer overflow vulnerabilities.</li><li>Fixing unsigned integer overflow by adding checks can cause incorrect offset computation when failing to account for all additions.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P2</span>
              <span class="pattern-title">Fixing out-of-bounds write through size checks can cause integer overflow when type conversions or signedness mismatches are not handled.</span>
              <span class="pattern-count">(4 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing heap overflow by checking SIZE_MAX can cause integer overflow in signed int conversions.</li><li>Fixing overflow by upper-bound checks can cause negative-value bypass due to missing sign checks.</li><li>Fixing integer overflow using INT_MAX can cause improper allocations due to insufficient bound check against SIZE_MAX.</li><li>Fixing size_t overflows by additional checks can cause integer overflow due to incorrect casting.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P3</span>
              <span class="pattern-title">Fixing out-of-bounds write by adding size calculations can cause integer overflow when arithmetic operations lack overflow protection.</span>
              <span class="pattern-count">(3 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing memory allocation size by multiplying without checks can cause integer overflow.</li><li>Fixing buffer overflow by adding bounds check can cause integer overflow in size calculations.</li><li>Fixing empty section handling by adjusting write index can cause incorrect arithmetic leading to overflow.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-119] → [CWE-362] Concurrent Execution using Shared Resource with Improper Synchronization (&#x27;Race Condition&#x27;)</h2>
          <div class="meta">
            <span class="stats">Patterns: 4 • Records: 9</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing overflow with validation but without atomicity (locks/RCU/atomics) creates check-then-use races under concurrency.</span>
              <span class="pattern-count">(6 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing crash via async checks can cause race conditions by neglecting thread-safe synchronization.</li><li>Fixing overflow by adding size checks can cause a race condition with truncation operations.</li><li>Fixing unmapped area handling by stopping on first failed copy can cause race conditions when appending.</li><li>Fixing buffer overflow by alignment check can cause race conditions with concurrent page access.</li><li>Fixing extent tree initialization by variable reassignment can cause race conditions without proper synchronization.</li><li>Fixing buffer boundary overflow by adding checks can cause a race condition in concurrent environments.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P2</span>
              <span class="pattern-title">Fixing header field checks by targeting specific global parameters can cause race condition issues with other fields.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing header field checks by targeting specific global parameters can cause race condition issues with other fields.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P3</span>
              <span class="pattern-title">Fixing task scheduling by marking tasks as running prematurely can cause race conditions.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing task scheduling by marking tasks as running prematurely can cause race conditions.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P4</span>
              <span class="pattern-title">Fixing page reference issues by adjusting mapping logic can cause race conditions in arch-specific data handling.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing page reference issues by adjusting mapping logic can cause race conditions in arch-specific data handling.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-125] → [CWE-119] Improper Restriction of Operations within the Bounds of a Memory Buffer</h2>
          <div class="meta">
            <span class="stats">Patterns: 2 • Records: 9</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing out-of-bounds read with partial bounds checking can cause buffer overflow when related operations or code paths lack validation.</span>
              <span class="pattern-count">(6 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing buffer overrun by adding minimal bounds check can cause inadequate validation of extended buffer operations.</li><li>Fixing out-of-bound readings by adding bounds checks can cause re-introduction of out-of-bounds access by removing those checks.</li><li>Fixing buffer overflow by checking length can cause similar unchecked paths to remain vulnerable.</li><li>Fixing buffer over-read by adding bounds checks can cause inconsistent length tracking leading to buffer overflows.</li><li>Fixing buffer overrun by checking fixed offsets can cause other unchecked reads violating buffer bounds.</li><li>Fixing heap-buffer-overflow in one function without comprehensive bounds checks can cause similar issues in related functions.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P2</span>
              <span class="pattern-title">Fixing out-of-bounds read in one location can cause buffer overflow when similar issues in other locations or data types are not addressed.</span>
              <span class="pattern-count">(3 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing opcode alignment assumptions by unsafe pointer arithmetic can cause memory access violations across different memory pages.</li><li>Fixing PPM buffer overruns by static rescale allocation can cause buffer overflows for atypical color spaces.</li><li>Fixing offset validation in name table can cause missing checks in other tables.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-119] → [CWE-476] NULL Pointer Dereference</h2>
          <div class="meta">
            <span class="stats">Patterns: 3 • Records: 8</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing buffer overflow by adding bounds checks can cause NULL pointer dereference when NULL validation is not included.</span>
              <span class="pattern-count">(6 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing buffer overflow by adding length checks can cause NULL dereference due to unhandled empty packet lines.</li><li>Fixing section boundary checking by size verification can cause invalid memory accesses due to null pointer dereference.</li><li>Fixing out-of-bounds channel access by range checking can cause unchecked component indices to be dereferenced.</li><li>Fixing segfaults by break conditions without NULL checks can cause new NULL pointer dereferences.</li><li>Fixing buffer-overflows by range checks can cause NULL dereference when omitting object validity checks.</li><li>Fixing character encoding conversions without NULL checks can cause a NULL pointer dereference.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P2</span>
              <span class="pattern-title">Fixing excessive allocation length handling by lazy allocations can cause null dereference with zero-length checks.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing excessive allocation length handling by lazy allocations can cause null dereference with zero-length checks.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P3</span>
              <span class="pattern-title">Refactoring to prevent use-after-free by reordering checks can cause null pointer dereference in self-referential structures.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Refactoring to prevent use-after-free by reordering checks can cause null pointer dereference in self-referential structures.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-20] → [CWE-125] Out-of-bounds Read</h2>
          <div class="meta">
            <span class="stats">Patterns: 2 • Records: 8</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing improper input validation with partial checks can cause out-of-bounds read when comprehensive boundary validation is missing.</span>
              <span class="pattern-count">(5 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing offset checks by basic offsets verification can cause missing comprehensive boundary checks.</li><li>Fixing infinite loop by skipping zero-length segments can cause iovec overrun due to insufficient bounds checks.</li><li>Fixing channel trait checks by adding offset lookup can cause out-of-bounds read if offset is unvalidated.</li><li>Fixing complex parsing with strcspn can cause out-of-bounds reads by not respecting input length limits.</li><li>Fixing out-of-bounds read by basic bounds checks can cause incomplete coverage of buffer-related operations.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P2</span>
              <span class="pattern-title">Fixing improper input validation through logic changes can cause out-of-bounds read when pointer or condition handling introduces access errors.</span>
              <span class="pattern-count">(3 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing improper header copy by pointer reference change can cause out-of-bounds read from stack buffer.</li><li>Fixing reversed test logic by changing conditions can cause incorrect pointer dereferencing and lead to out-of-bounds access.</li><li>Fixing offset calculation by checking upper bounds can cause undetected buffer underflows.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-125] → [CWE-476] NULL Pointer Dereference</h2>
          <div class="meta">
            <span class="stats">Patterns: 3 • Records: 7</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing out-of-bounds read with checks/validation but omitting NULL checks on pointers/references causes NULL dereference.</span>
              <span class="pattern-count">(5 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing integer overflow by using size_t can cause NULL dereference due to unchecked match calls.</li><li>Fixing channel-component count mismatch by adding checks can cause null dereference due to insufficient component validation.</li><li>Fixing NULL references by checking certain paths can cause crashes in unchecked paths.</li><li>Fixing crash by code refactor can cause NULL dereference vulnerability due to omitted NULL checks.</li><li>Fixing crash by validating length fields can cause subsequent processing of NULL globals, leading to memory access issues.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P2</span>
              <span class="pattern-title">Fixing out-of-bounds read by bounds checking can cause unchecked NULL dereference on bitmap cache entries.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing out-of-bounds read by bounds checking can cause unchecked NULL dereference on bitmap cache entries.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P3</span>
              <span class="pattern-title">Fixing buffer overflow by extending buffer size incompletely can cause memory alignment issues and undefined behavior.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing buffer overflow by extending buffer size incompletely can cause memory alignment issues and undefined behavior.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-416] → [CWE-362] Concurrent Execution using Shared Resource with Improper Synchronization (&#x27;Race Condition&#x27;)</h2>
          <div class="meta">
            <span class="stats">Patterns: 2 • Records: 7</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P2</span>
              <span class="pattern-title">Fixing use-after-free by changing execution timing or state handling can cause race conditions when operations introduce unsafe concurrent access windows.</span>
              <span class="pattern-count">(4 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing element focus handling by altering execution behavior can cause security origin race conditions.</li><li>Fixing memory access patterns by altering state handling can cause speculative execution race condition vulnerabilities.</li><li>Fixing inode attribute fetch timing by reading post-RCU can cause race conditions due to invalid attribute reads.</li><li>Fixing use-after-free by correcting instance assignment can cause a race condition during callback setup.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing use-after-free through synchronization changes can cause race conditions when locking is incomplete or improperly scoped.</span>
              <span class="pattern-count">(3 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing race conditions by locking within functions can cause unsafe operations without locks across callers.</li><li>Fixing lock acquisition timing by moving read locks can cause data races in write operations.</li><li>Fixing use-after-free by moving notifications outside locks can cause race conditions during concurrent user control modifications.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-787] → [CWE-119] Improper Restriction of Operations within the Bounds of a Memory Buffer</h2>
          <div class="meta">
            <span class="stats">Patterns: 7 • Records: 7</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing buffer overflow by using pointers can cause undefined behavior due to unallocated memory usage.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing buffer overflow by using pointers can cause undefined behavior due to unallocated memory usage.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P2</span>
              <span class="pattern-title">Fixing embedded null handling by length mismanagement can cause buffer overruns.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing embedded null handling by length mismanagement can cause buffer overruns.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P3</span>
              <span class="pattern-title">Fixing compressed page bounds without checking uncompressed pages can cause out-of-bounds access in memory operations.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing compressed page bounds without checking uncompressed pages can cause out-of-bounds access in memory operations.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P4</span>
              <span class="pattern-title">Fixing version string handling by length checks can cause buffer overflow when formats aren&#x27;t accurately handled.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing version string handling by length checks can cause buffer overflow when formats aren&#x27;t accurately handled.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P5</span>
              <span class="pattern-title">Fixing index calculation by using max_x instead of line_size can cause buffer overflows.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing index calculation by using max_x instead of line_size can cause buffer overflows.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P6</span>
              <span class="pattern-title">Fixing integer overflow by adjusting size calculations can cause indeces to exceed valid LZW code bounds.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing integer overflow by adjusting size calculations can cause indeces to exceed valid LZW code bounds.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P7</span>
              <span class="pattern-title">Fixing nbucket zero-check by assuming consistent chains length can cause buffer overflows.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing nbucket zero-check by assuming consistent chains length can cause buffer overflows.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-787] → [CWE-120] Buffer Copy without Checking Size of Input (&#x27;Classic Buffer Overflow&#x27;)</h2>
          <div class="meta">
            <span class="stats">Patterns: 4 • Records: 7</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing buffer overflow with size adjustments but incomplete bounds checks/validations causes new buffer overflows.</span>
              <span class="pattern-count">(4 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing strncpy inefficiency by using strcpy can cause buffer overflow if size checks are bypassed.</li><li>Fixing buffer size to static values can cause buffer overflow due to missing null byte accounting.</li><li>Fixing buffer overflow via ADD_CHAR macros can cause overflow when bounds checks are incomplete.</li><li>Fixing zero-size malloc checks by incorrect size validations can cause buffer overflows due to unchecked length in buffer copies.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P2</span>
              <span class="pattern-title">Fixing out-of-bounds accesses by length checks can cause line truncation with fixed buffer sizes.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing out-of-bounds accesses by length checks can cause line truncation with fixed buffer sizes.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P3</span>
              <span class="pattern-title">Fixing out-of-bounds write by adding &#x27;&gt;=&#x27; boundary checks can cause incorrect checks allowing boundary writes.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing out-of-bounds write by adding &#x27;&gt;=&#x27; boundary checks can cause incorrect checks allowing boundary writes.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P4</span>
              <span class="pattern-title">Fixing buffer overflow by adjusting length before copy can cause later unsafe copy operations.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing buffer overflow by adjusting length before copy can cause later unsafe copy operations.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-119] → [CWE-120] Buffer Copy without Checking Size of Input (&#x27;Classic Buffer Overflow&#x27;)</h2>
          <div class="meta">
            <span class="stats">Patterns: 4 • Records: 6</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing buffer overflow with bounds adjustments but incomplete size validation causes new buffer overflows.</span>
              <span class="pattern-count">(3 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing pointer advancement before access can cause insufficient buffer size checks.</li><li>Fixing invalid pointer passing by access check can cause buffer overflow due to unchecked size modification.</li><li>Fixing incorrect bounds checks by using hardcoded lengths can cause improper buffer size validation.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P2</span>
              <span class="pattern-title">Fixing buffer overflow via changed boundary checks can cause unsafe writes due to premature copying.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing buffer overflow via changed boundary checks can cause unsafe writes due to premature copying.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P3</span>
              <span class="pattern-title">Fixing OOB write by code validation can cause buffer overflow from unvalidated pointer arithmetic.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing OOB write by code validation can cause buffer overflow from unvalidated pointer arithmetic.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P4</span>
              <span class="pattern-title">Fixing Pascal string handling by incorrect length calculation can cause buffer overflow.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing Pascal string handling by incorrect length calculation can cause buffer overflow.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-119] → [CWE-787] Out-of-bounds Write</h2>
          <div class="meta">
            <span class="stats">Patterns: 6 • Records: 6</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing packet size mismatches by logging only can cause out-of-bounds writes for mismatched fragmented packets.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing packet size mismatches by logging only can cause out-of-bounds writes for mismatched fragmented packets.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P2</span>
              <span class="pattern-title">Fixing buffer overflow by bounds check removal can cause unchecked writes exceeding buffer limits.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing buffer overflow by bounds check removal can cause unchecked writes exceeding buffer limits.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P3</span>
              <span class="pattern-title">Fixing indirect stack accesses checks by conditional restrictions allows pointer manipulation vulnerabilities when conditions are met.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing indirect stack accesses checks by conditional restrictions allows pointer manipulation vulnerabilities when conditions are met.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P4</span>
              <span class="pattern-title">Fixing heap overflow by checking dimensions can cause similar vulnerabilities in related functions.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing heap overflow by checking dimensions can cause similar vulnerabilities in related functions.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P5</span>
              <span class="pattern-title">Fixing background color check by skipping bounds check can cause out-of-bounds memory access on truecolor images.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing background color check by skipping bounds check can cause out-of-bounds memory access on truecolor images.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P6</span>
              <span class="pattern-title">Fixing out-of-bounds issue by adjusting string handling can cause buffer overflow in file processing.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing out-of-bounds issue by adjusting string handling can cause buffer overflow in file processing.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-125] → [CWE-20] Improper Input Validation</h2>
          <div class="meta">
            <span class="stats">Patterns: 4 • Records: 6</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing out-of-bounds read with partial checks but incomplete validation of related dimensions/inputs causes improper input validation.</span>
              <span class="pattern-count">(3 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing zero-width scenarios by single-dimensional checks can cause incomplete validation for other critical dimensions.</li><li>Fixing out-of-bounds read by substream checks can cause inadequate validation of tilesDataSize leading to buffer overflow.</li><li>Fixing rank check by verifying input rank &gt;= 2 can cause incomplete validation leading to unexpected behavior.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P2</span>
              <span class="pattern-title">Fixing overflow by adding bounds checks can cause zero-length input mishandling.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing overflow by adding bounds checks can cause zero-length input mishandling.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P3</span>
              <span class="pattern-title">Fixing parsing validation by adding performance optimizations can cause improper input validation.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing parsing validation by adding performance optimizations can cause improper input validation.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P4</span>
              <span class="pattern-title">Fixing buffer over-read by rigid length checks can cause denial of service on shorter valid messages.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing buffer over-read by rigid length checks can cause denial of service on shorter valid messages.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-416] → [CWE-190] Integer Overflow or Wraparound</h2>
          <div class="meta">
            <span class="stats">Patterns: 6 • Records: 6</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing use-after-free vulnerability by altering condition check can cause failure in detecting partial data copies due to integer discrepancy.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing use-after-free vulnerability by altering condition check can cause failure in detecting partial data copies due to integer discrepancy.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P2</span>
              <span class="pattern-title">Fixing reference deserialization by early failures can cause signed integer overflow in subsequent parsing.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing reference deserialization by early failures can cause signed integer overflow in subsequent parsing.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P3</span>
              <span class="pattern-title">Fixing loop handling by altering loop depth can cause integer underflow.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing loop handling by altering loop depth can cause integer underflow.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P4</span>
              <span class="pattern-title">Fixing buffer initialization by checking maxPlaneSize can cause integer overflow on high-resolution inputs.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing buffer initialization by checking maxPlaneSize can cause integer overflow on high-resolution inputs.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P5</span>
              <span class="pattern-title">Fixing stream resource management by altering closure logic can cause unchecked arithmetic leading to overflows.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing stream resource management by altering closure logic can cause unchecked arithmetic leading to overflows.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P6</span>
              <span class="pattern-title">Fixing a previous bug using basic emalloc() can cause integer overflow during array memory allocation.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing a previous bug using basic emalloc() can cause integer overflow during array memory allocation.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-119] → [CWE-415] Double Free</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 5</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing buffer overflow with resource management/cleanup but incomplete handling of error paths/callbacks causes double free.</span>
              <span class="pattern-count">(5 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing crash by reseting counters can cause double frees if cleanup does not adjust to the new counts.</li><li>Fixing use-after-free by clearing buffer in FinishLoading can cause double free if callback order is mismanaged.</li><li>Fixing vector validation by adding error recovery can cause double free if index is misused.</li><li>Fixing out-of-bound read by adding resource management can cause double free on error paths.</li><li>Fixing Use-After-Free and Double-Free by added checks can cause additional double free scenarios due to incomplete handling.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-119] → [CWE-693] Protection Mechanism Failure</h2>
          <div class="meta">
            <span class="stats">Patterns: 2 • Records: 5</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing buffer overflow with overly restrictive/strict bounds checks causes false rejection of valid inputs.</span>
              <span class="pattern-count">(4 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing buffer overflows by overly restrictive bounds checks can cause false negatives on valid input.</li><li>Fixing buffer overrun by pre-checks can cause skipped bounds validation on specific types.</li><li>Fixing invalid file size rejection by strict length checks can cause legitimate file access to be denied.</li><li>Fixing color boundary validation by strict checks can cause unwanted rejection of valid operations.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P2</span>
              <span class="pattern-title">Fixing 32-bit ALU op verification can cause stack slot reuse issues leading to speculative execution vulnerabilities.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing 32-bit ALU op verification can cause stack slot reuse issues leading to speculative execution vulnerabilities.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-189] → [CWE-190] Integer Overflow or Wraparound</h2>
          <div class="meta">
            <span class="stats">Patterns: 4 • Records: 5</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing integer overflow with incomplete size calculations/bounds-checking causes similar unchecked overflow in related operations.</span>
              <span class="pattern-count">(2 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing integer overflow by incomplete size calculations can cause additional overflow vulnerabilities.</li><li>Fixing overflow in one allocation by bounds-checking may cause similar unchecked overflow in another allocation.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P2</span>
              <span class="pattern-title">Fixing divide-by-zero by checking zero divisor can cause unchecked signed integer subtraction.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing divide-by-zero by checking zero divisor can cause unchecked signed integer subtraction.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P3</span>
              <span class="pattern-title">Fixing value representation by extending to s64 can cause integer overflows due to unbounded shifts.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing value representation by extending to s64 can cause integer overflows due to unbounded shifts.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P4</span>
              <span class="pattern-title">Fixing premature reallocation increment by conditional resize checks can cause integer overflow on multiplication.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing premature reallocation increment by conditional resize checks can cause integer overflow on multiplication.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-190] → [CWE-681] Incorrect Conversion between Numeric Types</h2>
          <div class="meta">
            <span class="stats">Patterns: 2 • Records: 5</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing integer overflow with constraints/checks but improper type conversions (signed/float/integer transitions) causes conversion errors.</span>
              <span class="pattern-count">(4 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing overflow with int-based checks can cause bypass due to signed conversion before checking.</li><li>Fixing overflow by constraining values can cause unsafe type conversion issues.</li><li>Fixing non-negative enforcement by MagickMax can cause improper value conversions during float to integer transitions.</li><li>Fixing potential integer overflow by constraining doubles incorrectly can cause incorrect type conversion issues.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P2</span>
              <span class="pattern-title">Fixing floating-point arithmetic by casting to integer can cause overflow on insufficient range checks.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing floating-point arithmetic by casting to integer can cause overflow on insufficient range checks.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-20] → [CWE-362] Concurrent Execution using Shared Resource with Improper Synchronization (&#x27;Race Condition&#x27;)</h2>
          <div class="meta">
            <span class="stats">Patterns: 5 • Records: 5</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P2</span>
              <span class="pattern-title">Fixing symlink security by blocking directory symlinks can cause denial of valid hardlink extractions.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing symlink security by blocking directory symlinks can cause denial of valid hardlink extractions.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing validation with checks/verification but without atomicity creates check-then-use races under concurrency.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing stale dentry checks by direct verification can cause race condition issues.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P3</span>
              <span class="pattern-title">Fixing anonymous page handling by issuing SIGBUS can cause a race condition during PTE temporary clearing.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing anonymous page handling by issuing SIGBUS can cause a race condition during PTE temporary clearing.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P4</span>
              <span class="pattern-title">Fixing race conditions by adding locks can cause new race conditions when locks are incomplete.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing race conditions by adding locks can cause new race conditions when locks are incomplete.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P6</span>
              <span class="pattern-title">Fixing TLB flushing by modifying shadow mode behavior can cause premature release of shadow page tables.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing TLB flushing by modifying shadow mode behavior can cause premature release of shadow page tables.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-20] → [CWE-703] Improper Check or Handling of Exceptional Conditions</h2>
          <div class="meta">
            <span class="stats">Patterns: 5 • Records: 5</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing negative copy checks by erroring out can cause valid splice operations to fail.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing negative copy checks by erroring out can cause valid splice operations to fail.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P2</span>
              <span class="pattern-title">Fixing ICMPv6 device usage by fallback to dst can cause incorrect VRF routing table lookups.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing ICMPv6 device usage by fallback to dst can cause incorrect VRF routing table lookups.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P3</span>
              <span class="pattern-title">Fixing failure returns by ignoring zero-length messages can cause missed processing of valid notifications.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing failure returns by ignoring zero-length messages can cause missed processing of valid notifications.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P4</span>
              <span class="pattern-title">Fixing origin verification by process termination can cause denial of service through controllable exits.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing origin verification by process termination can cause denial of service through controllable exits.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P5</span>
              <span class="pattern-title">Fixing decryption by using captured length can cause failures when payload is truncated.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing decryption by using captured length can cause failures when payload is truncated.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-200] → [CWE-362] Race Condition</h2>
          <div class="meta">
            <span class="stats">Patterns: 4 • Records: 5</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing info leak with checks/initialization but incomplete atomicity (missing locks/improper locking) creates races under concurrency.</span>
              <span class="pattern-count">(2 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing an info leak by initializing channel to 0 can cause a race condition due to unprotected checks.</li><li>Fixing queue index reset without locking can cause race conditions during concurrent access.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P3</span>
              <span class="pattern-title">Fixing AIO verification by additional checks can cause race conditions in ring page migrations.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing AIO verification by additional checks can cause race conditions in ring page migrations.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P4</span>
              <span class="pattern-title">Fixing memory leak by zero-initialization can cause race conditions in completion handling.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing memory leak by zero-initialization can cause race conditions in completion handling.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P5</span>
              <span class="pattern-title">Fixing address exposure by using document offset can cause ID collision when nodes share an offset.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing address exposure by using document offset can cause ID collision when nodes share an offset.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-369] → [CWE-190] Integer Overflow or Wraparound</h2>
          <div class="meta">
            <span class="stats">Patterns: 3 • Records: 5</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing divide-by-zero with checks/validation but unchecked arithmetic in related operations causes integer overflow.</span>
              <span class="pattern-count">(3 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing division-by-zero by restricting shifts can cause integer overflow during unchecked shift operations.</li><li>Fixing invalid channel count by verifying num_channels can cause integer overflows in subsequent sample calculations.</li><li>Fixing division by zero by checking non-zero values can cause integer overflow with large multiplications.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P2</span>
              <span class="pattern-title">Fixing divide-by-zero by reciprocal can cause numerical instability with small values in floating-point operations.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing divide-by-zero by reciprocal can cause numerical instability with small values in floating-point operations.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P3</span>
              <span class="pattern-title">Fixing overflow detection by manual checks can cause undetected overflows when logic misses cases.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing overflow detection by manual checks can cause undetected overflows when logic misses cases.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-400] → [CWE-416] Use After Free</h2>
          <div class="meta">
            <span class="stats">Patterns: 3 • Records: 5</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing memory leak by freeing buffers/resources on error paths causes use-after-free if cleanup overlaps with continued usage.</span>
              <span class="pattern-count">(3 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing timeout memory leaks by freeing buffers can cause use-after-free vulnerabilities.</li><li>Fixing memory leak by freeing buffers on timeout can cause use-after-free if buffers are already consumed.</li><li>Fixing memory leak by handling errors can cause use-after-free if resource cleanup overlaps.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P2</span>
              <span class="pattern-title">Fixing memory management by setting pointers to NULL can cause access to freed memory.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing memory management by setting pointers to NULL can cause access to freed memory.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P3</span>
              <span class="pattern-title">Fixing property management by altering deletion logic can cause use-after-free errors.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing property management by altering deletion logic can cause use-after-free errors.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-476] → [CWE-362] Concurrent Execution using Shared Resource with Improper Synchronization (&#x27;Race Condition&#x27;)</h2>
          <div class="meta">
            <span class="stats">Patterns: 4 • Records: 5</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing NULL dereference with checks/locks but incomplete synchronization (missing locks/improper locking) creates races under concurrency.</span>
              <span class="pattern-count">(2 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing key checks by adding &#x27;has_key&#x27; can cause race conditions through improper socket locking.</li><li>Fixing subflow disconnection by changing traversal method can cause race condition due to missing socket locks.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P3</span>
              <span class="pattern-title">Fixing heap overflow by length checks can cause incorrect rejection of valid transactions.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing heap overflow by length checks can cause incorrect rejection of valid transactions.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P2</span>
              <span class="pattern-title">Fixing NULL dereference by conditional checks can cause race conditions leading to new null dereferences.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing NULL dereference by conditional checks can cause race conditions leading to new null dereferences.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P4</span>
              <span class="pattern-title">Fixing NULL dereference by checking primary can cause misuse of shared resources during concurrent event processing.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing NULL dereference by checking primary can cause misuse of shared resources during concurrent event processing.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-476] → [CWE-416] Use After Free</h2>
          <div class="meta">
            <span class="stats">Patterns: 3 • Records: 5</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing NULL dereference with memory/resource management but improper synchronization/state handling causes use-after-free.</span>
              <span class="pattern-count">(3 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing NULL dereference by conditionally managing memory can cause use-after-free if previous memory is reused unsafely.</li><li>Fixing null pointer dereference by null check addition can cause improper resource management with concurrent state changes.</li><li>Fixing NULL dereference via mutex locks can cause use-after-free due to improper synchronization of shared resources.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P2</span>
              <span class="pattern-title">Fixing initialization oversight by removing nulling causes use-after-free vulnerability under certain conditions.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing initialization oversight by removing nulling causes use-after-free vulnerability under certain conditions.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P3</span>
              <span class="pattern-title">Fixing null pointer dereference by asserting pointers can cause incorrect reference counting leading to use-after-free.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing null pointer dereference by asserting pointers can cause incorrect reference counting leading to use-after-free.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-787] → [CWE-125] Out-of-bounds Read</h2>
          <div class="meta">
            <span class="stats">Patterns: 5 • Records: 5</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing long-form ASN.1 length validation can cause out-of-bounds read by missing short-form validation.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing long-form ASN.1 length validation can cause out-of-bounds read by missing short-form validation.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P2</span>
              <span class="pattern-title">Fixing PT_DYNAMIC checks by adding size constraints can cause inadequate handling of segment offsets.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing PT_DYNAMIC checks by adding size constraints can cause inadequate handling of segment offsets.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P3</span>
              <span class="pattern-title">Fixing potential overflow by checking constant sizes can cause ignored variable offsets in bounds checks.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing potential overflow by checking constant sizes can cause ignored variable offsets in bounds checks.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P4</span>
              <span class="pattern-title">Fixing xref_len-based resizing can cause array overflows if page object numbers exceed bounds.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing xref_len-based resizing can cause array overflows if page object numbers exceed bounds.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P5</span>
              <span class="pattern-title">Fixing inadequate boundary checks by using incomplete file size calculations can cause out-of-bounds reads.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing inadequate boundary checks by using incomplete file size calculations can cause out-of-bounds reads.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-787] → [CWE-193] Off-by-one Error</h2>
          <div class="meta">
            <span class="stats">Patterns: 2 • Records: 5</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing buffer overflow with boundary checks/comparisons (&gt;=, inclusive) causes off-by-one errors in array access/validation.</span>
              <span class="pattern-count">(4 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing a buffer boundary check by using &#x27;&gt;=&#x27; can cause off-by-one array access errors.</li><li>Fixing out-of-bounds errors by adding boundary checks can cause off-by-one validation issues.</li><li>Fixing UTF-8 invalid sequence handling by adjusting parsing logic can cause off-by-one errors.</li><li>Fixing buffer bounds by inclusive comparison can cause off-by-one errors.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P2</span>
              <span class="pattern-title">Fixing buffer overflow by resetting size can cause incorrect buffer size reduction with initial backspace in feedback mode.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing buffer overflow by resetting size can cause incorrect buffer size reduction with initial backspace in feedback mode.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-119] → [CWE-126] Buffer Over-read</h2>
          <div class="meta">
            <span class="stats">Patterns: 4 • Records: 4</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing colormap index bounds by strict inequality check can cause buffer over-read when indices are equal.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing colormap index bounds by strict inequality check can cause buffer over-read when indices are equal.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P2</span>
              <span class="pattern-title">Fixing stack pointer alignment by enforcing strict checks can cause incorrect register truncation logic.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing stack pointer alignment by enforcing strict checks can cause incorrect register truncation logic.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P3</span>
              <span class="pattern-title">Fixing out-of-bounds read by index adjustment can cause invalid read with empty elements.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing out-of-bounds read by index adjustment can cause invalid read with empty elements.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P4</span>
              <span class="pattern-title">Fixing buffer overruns by adding sentinels can cause unexpected overreads during header processing.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing buffer overruns by adding sentinels can cause unexpected overreads during header processing.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-119] → [CWE-401] Missing Release of Memory after Effective Lifetime</h2>
          <div class="meta">
            <span class="stats">Patterns: 4 • Records: 4</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P2</span>
              <span class="pattern-title">Fixing memory allocation by moving initialization can cause memory leaks on format failure.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing memory allocation by moving initialization can cause memory leaks on format failure.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P3</span>
              <span class="pattern-title">Fixing buffer overflow by early return can cause memory leak when cleanup code gets bypassed.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing buffer overflow by early return can cause memory leak when cleanup code gets bypassed.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing overflow with checks/modifications but omitting resource cleanup on error paths causes memory leaks.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing buffer overflows by dimension checks can cause memory leaks when resources are not released on exceptions.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P4</span>
              <span class="pattern-title">Fixing buffer overflow by adding boundary checks can cause memory leaks by neglecting memory deallocation.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing buffer overflow by adding boundary checks can cause memory leaks by neglecting memory deallocation.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-119] → [CWE-416] Use After Free</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 4</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing buffer overflow with state/pointer changes but incomplete lifecycle handling causes use-after-free.</span>
              <span class="pattern-count">(4 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing parsing errors by immediate termination can cause use-after-free when state handling is incomplete.</li><li>Fixing a crash by nullifying a pointer can cause use-after-free during buffer reallocations.</li><li>Fixing out-of-bounds read by modifying index access can cause access to freed memory.</li><li>Fixing stack overflow prevention by limiting depth can cause improper tree node handling leading to UAF conditions.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-119] → [CWE-704] Incorrect Type Conversion or Cast</h2>
          <div class="meta">
            <span class="stats">Patterns: 4 • Records: 4</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing size field sign checks by removing them can cause unchecked conversion vulnerabilities.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing size field sign checks by removing them can cause unchecked conversion vulnerabilities.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P2</span>
              <span class="pattern-title">Fixing SSL non-blocking with retry loops can cause SSL operation vulnerabilities.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing SSL non-blocking with retry loops can cause SSL operation vulnerabilities.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P3</span>
              <span class="pattern-title">Fixing buffer overflow via bounds checking can cause incorrect variable assignment due to copy-paste errors.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing buffer overflow via bounds checking can cause incorrect variable assignment due to copy-paste errors.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P4</span>
              <span class="pattern-title">Fixing buffer underrun with hardcoded sizes can cause overflow from mismatched cipher block sizes.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing buffer underrun with hardcoded sizes can cause overflow from mismatched cipher block sizes.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-190] → [CWE-682] Incorrect Calculation</h2>
          <div class="meta">
            <span class="stats">Patterns: 3 • Records: 4</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing integer overflow with value handling but incorrect computation logic causes wrong results.</span>
              <span class="pattern-count">(2 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing power calculation by handling negative values can cause incorrect handling of fractional exponents.</li><li>Fixing negative quantum values by returning 0 can cause incorrect HDRI calculation results.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P2</span>
              <span class="pattern-title">Fixing overflow by adding macros with missing parentheses can cause incorrect evaluation during macro expansion.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing overflow by adding macros with missing parentheses can cause incorrect evaluation during macro expansion.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P3</span>
              <span class="pattern-title">Fixing buffer overflow with bit-shifting can cause incorrect rounding errors that lead to buffer overflow.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing buffer overflow with bit-shifting can cause incorrect rounding errors that lead to buffer overflow.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-362] → [CWE-416] Use After Free</h2>
          <div class="meta">
            <span class="stats">Patterns: 2 • Records: 4</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing race condition with locks/synchronization but incomplete lifecycle/reference management causes use-after-free.</span>
              <span class="pattern-count">(3 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing race condition by added locks can cause inconsistent lifecycle handling across socket types.</li><li>Fixing reference counting by acquiring reference before FD creation can cause similar use-after-free when missed.</li><li>Fixing race condition by MSG_PEEK synchronization can cause use-after-free in concurrent socket queue management.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P2</span>
              <span class="pattern-title">Fixing double-unlink by reassigning NULL can cause use-after-free if the parent structure is also released.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing double-unlink by reassigning NULL can cause use-after-free if the parent structure is also released.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-399] → [CWE-362] Concurrent Execution using Shared Resource with Improper Synchronization (&#x27;Race Condition&#x27;)</h2>
          <div class="meta">
            <span class="stats">Patterns: 2 • Records: 4</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing resource management with control flow/timing changes but incomplete synchronization causes races in concurrent operations.</span>
              <span class="pattern-count">(3 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing lock re-entry by releasing locks early can cause race conditions in GPU information updates.</li><li>Fixing parser destruction by reference protection in doWrite can cause race conditions with unsynced operations in finish.</li><li>Fixing resource cleanup by control flow change can cause a race condition during file operations.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P2</span>
              <span class="pattern-title">Fixing access to freed members by CAS can cause data races due to inconsistent synchronization.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing access to freed members by CAS can cause data races due to inconsistent synchronization.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-399] → [CWE-416] Use After Free</h2>
          <div class="meta">
            <span class="stats">Patterns: 4 • Records: 4</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing racing issues by stopping threads can cause use-after-free due to improper destruction order.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing racing issues by stopping threads can cause use-after-free due to improper destruction order.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P2</span>
              <span class="pattern-title">Fixing XPath evaluation by freeing objects directly can cause stack mismanagement and use-after-free bugs.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing XPath evaluation by freeing objects directly can cause stack mismanagement and use-after-free bugs.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P3</span>
              <span class="pattern-title">Fixing error path memory leaks by shared buffer can cause race conditions leading to UAF.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing error path memory leaks by shared buffer can cause race conditions leading to UAF.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P4</span>
              <span class="pattern-title">Fixing tag attribute handling by omitting pointer nullification can cause use-after-free issues.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing tag attribute handling by omitting pointer nullification can cause use-after-free issues.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-399] → [CWE-476] NULL Pointer Dereference</h2>
          <div class="meta">
            <span class="stats">Patterns: 2 • Records: 4</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing resource management with reordering/changes but missing NULL checks on pointers causes NULL dereference.</span>
              <span class="pattern-count">(3 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing resource leak by unconditionally calling resv_map_put can cause NULL pointer dereference.</li><li>Fixing IOMMU slot handling by sequence reordering can cause NULL pointer dereference during concurrent initializations.</li><li>Fixing cross-object selection by view-checking can cause null dereferences if object pointers are unchecked.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P2</span>
              <span class="pattern-title">Fixing null pointer dereference by moving checks can cause overlooked dereferences elsewhere.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing null pointer dereference by moving checks can cause overlooked dereferences elsewhere.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-416] → [CWE-362] Race Condition</h2>
          <div class="meta">
            <span class="stats">Patterns: 2 • Records: 4</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P2</span>
              <span class="pattern-title">Fixing use-after-free by changing execution timing or state handling can cause race conditions when operations introduce unsafe concurrent access windows.</span>
              <span class="pattern-count">(3 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing synchronous event dispatch by making it asynchronous can cause race conditions with event handling.</li><li>Fixing refcount leaks by moving refcount operations can cause premature resource release due to race conditions.</li><li>Fixing use-after-free via delayed flag setting can cause race conditions with uninitialized field access.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing use-after-free through synchronization changes can cause race conditions when locking is incomplete or improperly scoped.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing use-after-free by taking a reference can cause race condition due to improper synchronization of reference release.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-476] → [CWE-119] Improper Restriction of Operations within the Bounds of a Memory Buffer</h2>
          <div class="meta">
            <span class="stats">Patterns: 2 • Records: 4</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing NULL dereference with partial checks but missing similar checks in related paths causes buffer overflow.</span>
              <span class="pattern-count">(3 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing dense shape emptiness check by adding async requirements can cause dimension mismatch leading to buffer overflow.</li><li>Fixing monochrome image handling by excluding chroma processing can cause buffer overflows by missing similar checks in bipred functions.</li><li>Fixing monochrome handling by adding partial checks can cause buffer overflows in unchecked paths.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P2</span>
              <span class="pattern-title">Fixing out-of-bounds access by strict size checks can cause valid binaries to be improperly rejected.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing out-of-bounds access by strict size checks can cause valid binaries to be improperly rejected.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-476] → [CWE-190] Integer Overflow or Wraparound</h2>
          <div class="meta">
            <span class="stats">Patterns: 2 • Records: 4</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing NULL dereference with checks/tracking but unchecked arithmetic in related calculations causes integer overflow.</span>
              <span class="pattern-count">(3 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing pointer overflow by invalid arithmetic checks can cause undefined optimization side effects.</li><li>Fixing buffer overflow by offset tracking can cause integer overflow in offset calculations.</li><li>Fixing NULL pointer dereference by adding checks can cause integer overflow in buffer size calculations.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P2</span>
              <span class="pattern-title">Fixing preview dimension comparisons by altering conditions can cause overflow risks due to reduced arithmetic precision.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing preview dimension comparisons by altering conditions can cause overflow risks due to reduced arithmetic precision.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-476] → [CWE-401] Improper Release of Memory Before Removing Last Reference (&#x27;Memory Leak&#x27;)</h2>
          <div class="meta">
            <span class="stats">Patterns: 2 • Records: 4</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing NULL dereference with checks/modifications but omitting cleanup on error paths causes memory leaks.</span>
              <span class="pattern-count">(3 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing window management code by removing error checks can cause memory leaks when allocations are not freed on error.</li><li>Fixing NULL pointer checks by reallocating resources can cause memory leaks and resource exhaustion.</li><li>Fixing NULL dereference by adding pointer checks can cause memory leaks if cleanup routines are absent.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P4</span>
              <span class="pattern-title">Fixing null pointer dereference by early return can cause memory to be leaked on repeated flows.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing null pointer dereference by early return can cause memory to be leaked on repeated flows.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-772] → [CWE-401] Missing Release of Memory after Effective Lifetime</h2>
          <div class="meta">
            <span class="stats">Patterns: 2 • Records: 4</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P2</span>
              <span class="pattern-title">Fixing resource leaks in specific error paths can cause memory leaks when other error paths or control flow changes lack cleanup.</span>
              <span class="pattern-count">(3 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing memory leaks by adding cleanup before exceptions can cause overlooking similar leaks in other error paths.</li><li>Fixing selective memory cleanup by adding targeted xref releases can cause inconsistent leak management across error paths.</li><li>Fixing memory allocation failures by adding cleanup can cause leaks on other error paths.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing resource leaks with partial cleanup can cause memory leaks when other allocated resources remain unreleased.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing memory leaks by freeing specific variables can cause other variables to remain unfreed.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-787] → [CWE-131] Incorrect Calculation of Buffer Size</h2>
          <div class="meta">
            <span class="stats">Patterns: 2 • Records: 4</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing buffer overflow with fixed padding/factors but incorrect size calculations for varying inputs causes memory misallocation.</span>
              <span class="pattern-count">(3 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing buffer issues by adding fixed padding can cause memory misallocation when channel counts differ.</li><li>Fixing heap-buffer-overflow by multiplying fixed factors can cause incorrect buffer size calculations.</li><li>Fixing buffer overflow by static size assertion can cause incorrect calculation of buffer size for special encoding cases.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P2</span>
              <span class="pattern-title">Fixing buffer overflow by silent character truncation can cause data corruption through mismanaged character encoding.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing buffer overflow by silent character truncation can cause data corruption through mismanaged character encoding.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-787] → [CWE-401] Missing Release of Memory after Effective Lifetime</h2>
          <div class="meta">
            <span class="stats">Patterns: 2 • Records: 4</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing buffer overflow with memory allocation/management but omitting cleanup/deallocation on error paths causes memory leaks.</span>
              <span class="pattern-count">(3 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing buffer overflow by allocating memory can cause memory leaks due to improper cleanup in error paths.</li><li>Fixing input validation and adding functionality can cause memory leaks on error paths by omitting deallocation.</li><li>Fixing GIF memory allocation issues can cause memory leaks on realloc failure.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P2</span>
              <span class="pattern-title">Fixing invalid message handling by dropping them can cause memory leaks due to unreleased buffers.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing invalid message handling by dropping them can cause memory leaks due to unreleased buffers.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-787] → [CWE-476] NULL Pointer Dereference</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 4</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing buffer overflow with size/length checks but inadequate NULL pointer validation causes NULL dereference.</span>
              <span class="pattern-count">(4 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing out-of-bounds read by adding size checks can cause inadequate NULL pointer checks.</li><li>Fixing buffer overflow by checking lengths early can cause NULL pointer dereference when order of checks is incorrect.</li><li>Fixing uninitialized variable by conditional writes can cause NULL pointer dereference if out is not checked.</li><li>Fixing buffer overflow by adding checks can cause null dereference due to unhandled allocation failures.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-119] → [CWE-131] Incorrect Calculation of Buffer Size</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 3</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing buffer overflow with size calculations/allocations but insufficient accounting for padding/varying sizes causes inadequate memory allocation.</span>
              <span class="pattern-count">(3 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing memory allocation by MagickMax calculation can cause insufficient memory allocation for padding bytes.</li><li>Fixing buffer overrun by manual list resizing can cause incorrect buffer size calculations during varying xref_len.</li><li>Fixing buffer overflow by incrementally growing buffer size can cause inadequate allocation for varied context usages.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-119] → [CWE-367] Time-of-check Time-of-use (TOCTOU) Race Condition</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 3</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing buffer overflow by changing buffer allocation or size calculations can introduce TOCTOU race conditions when operations become non-atomic.</span>
              <span class="pattern-count">(3 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing buffer overflow by adjusting size check can cause TOCTOU issues.</li><li>Fixing memory usage via manual buffer calculations can cause TOCTOU issues in subsequent request handling.</li><li>Fixing stack buffer allocation issue by using heap buffers can cause race conditions in buffer handling.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-119] → [CWE-401] Improper Release of Memory Before Removing Last Reference (&#x27;Memory Leak&#x27;)</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 3</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing overflow with checks/modifications but omitting resource cleanup on error paths causes memory leaks.</span>
              <span class="pattern-count">(3 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing non-initialized fields by memset() can cause improper memory release before re-allocation, leading to leaks.</li><li>Fixing OOM by failing on allocation can cause memory leaks if cleanup is omitted on failure.</li><li>Fixing handler calls by adjusting zval structure can cause improper memory cleanup.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-119] → [CWE-703] Improper Check or Handling of Exceptional Conditions</h2>
          <div class="meta">
            <span class="stats">Patterns: 3 • Records: 3</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing sparing table loading by adding checks can cause incorrect error status reporting.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing sparing table loading by adding checks can cause incorrect error status reporting.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P2</span>
              <span class="pattern-title">Fixing sign extension in BPF can cause out-of-bounds speculation.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing sign extension in BPF can cause out-of-bounds speculation.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P3</span>
              <span class="pattern-title">Fixing negative index by adding boundary checks can cause incorrect logic in white space removal.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing negative index by adding boundary checks can cause incorrect logic in white space removal.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-120] → [CWE-190] Integer Overflow or Wraparound</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 3</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing buffer copy vulnerabilities by adding size checks can introduce integer overflow when arithmetic operations on sizes lack proper bounds validation.</span>
              <span class="pattern-count">(3 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing buffer overflow by adding length checks can cause integer overflow vulnerabilities when arithmetic operations are misordered.</li><li>Fixing array access with zero elements by size checks can cause integer overflows with excessive bit calculations.</li><li>Fixing layer ID bounds by setting unset values can cause unchecked bit shifts with overflow.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-125] → [CWE-120] Buffer Copy without Checking Size of Input (&#x27;Classic Buffer Overflow&#x27;)</h2>
          <div class="meta">
            <span class="stats">Patterns: 3 • Records: 3</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing s_first_meta_bg validation can cause unchecked buffer overflow in count_overhead.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing s_first_meta_bg validation can cause unchecked buffer overflow in count_overhead.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P2</span>
              <span class="pattern-title">Fixing string handling by changing locale functions can cause unchecked buffer access.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing string handling by changing locale functions can cause unchecked buffer access.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P3</span>
              <span class="pattern-title">Fixing out-of-bounds read by state tracking can cause buffer overflow with multi-byte character mishandling.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing out-of-bounds read by state tracking can cause buffer overflow with multi-byte character mishandling.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-125] → [CWE-457] Use of Uninitialized Variable</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 3</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing buffer over-read by adjusting buffer handling or data validation can cause use of uninitialized memory when all code paths do not properly initialize variables.</span>
              <span class="pattern-count">(3 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing netlink message length by checking nlh-&gt;nlmsg_len can cause use of uninitialized memory.</li><li>Fixing memory allocation with conditional limits can cause uninitialized memory use.</li><li>Fixing buffer overflow by adjusting data length can cause uninitialized variable use if all paths don&#x27;t set it.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-125] → [CWE-697] Incorrect Comparison</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 3</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing buffer over-read by adding or modifying bounds checks can introduce incorrect comparison logic through flawed validation conditions.</span>
              <span class="pattern-count">(3 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing data validation in protocol requests by copy-paste can cause incorrect comparison logic.</li><li>Fixing buffer overflow by incorrect bounds check can cause unnecessary rejection of valid serialized data.</li><li>Fixing out-of-bounds by incomplete bounds checking can cause flawed descriptor structure validation.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-190] → [CWE-191] Integer Underflow (Wrap or Wraparound)</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 3</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing integer overflow by adding checks or type conversions can introduce integer underflow when bidirectional bounds validation is missing.</span>
              <span class="pattern-count">(3 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing multiplication overflow with incorrect variable initialization can cause underflow risk in allocation calculation.</li><li>Fixing overflow checks after multiplication can cause insufficient error prevention in large integer arithmetic.</li><li>Fixing integer overflow by int64_t cast can cause underflow with opposite-signed operands.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-20] → [CWE-120] Buffer Copy without Checking Size of Input (&#x27;Classic Buffer Overflow&#x27;)</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 3</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing input validation incompletely can leave similar buffer copy vulnerabilities in related code paths or similar parsing logic.</span>
              <span class="pattern-count">(3 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing buffer overflow by adding length checks can cause incomplete coverage in similar code paths.</li><li>Fixing buffer overflow by adding length check can cause similar vulnerabilities in similar parsing logic.</li><li>Fixing signed parsing by type change can cause buffer overflow when bounds are not checked correctly.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-20] → [CWE-190] Integer Overflow or Wraparound</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 3</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing input validation by adding checks on one variable can introduce integer overflow when related arithmetic operations remain unchecked.</span>
              <span class="pattern-count">(3 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing zip parsing by limiting search distance can cause integer overflow vulnerabilities.</li><li>Fixing size validations by conditional checks can cause integer overflows on 32-bit systems.</li><li>Fixing divide-by-zero by checking list_len can cause integer overflow when list_count is unchecked.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-20] → [CWE-362] Race Condition</h2>
          <div class="meta">
            <span class="stats">Patterns: 2 • Records: 3</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing validation with checks/verification but without atomicity creates check-then-use races under concurrency.</span>
              <span class="pattern-count">(2 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing register access by adding validation can cause race conditions in PSTATE mode settings.</li><li>Fixing buffer bounds by incrementing offsets can cause incorrect bounds checks due to race conditions.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P5</span>
              <span class="pattern-title">Fixing keyring destruction by checking instantiation flags can cause race conditions due to non-atomic state checks.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing keyring destruction by checking instantiation flags can cause race conditions due to non-atomic state checks.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-20] → [CWE-416] Use After Free</h2>
          <div class="meta">
            <span class="stats">Patterns: 3 • Records: 3</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing focus retention by reordering method calls can cause use-after-free errors on invalid state assumptions.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing focus retention by reordering method calls can cause use-after-free errors on invalid state assumptions.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P2</span>
              <span class="pattern-title">Fixing empty security context handling by code restructuring can cause use-after-free in sidtab conversion.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing empty security context handling by code restructuring can cause use-after-free in sidtab conversion.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P3</span>
              <span class="pattern-title">Fixing a segfault by changing pointer handling can cause use-after-free errors.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing a segfault by changing pointer handling can cause use-after-free errors.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-20] → [CWE-476] NULL Pointer Dereference</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 3</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing input validation by adding checks can introduce null pointer dereference when null validation is placed after pointer dereference or checks are insufficient.</span>
              <span class="pattern-count">(3 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing payload absence by handling IKEv2 I1 notifications can cause dereference before validation.</li><li>Updating wddx_deserialize for memory safety can cause null pointer dereference without proper NULL checks.</li><li>Fixing parameter validation insufficiency by position-based NULL checks can cause premature NULL dereference.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-20] → [CWE-672] Operation on a Resource after Expiration or Release</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 3</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing input validation by modifying control flow can introduce incorrect resource lifecycle management through improper reference counting or resource tracking.</span>
              <span class="pattern-count">(3 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing frame activation logic by disabling can cause invalid frame sink references.</li><li>Fixing reference leaks by basic translation checks can cause incorrect resource handling for paged-out memory.</li><li>Fixing page table update checks by adjusting flow can cause memory leaks via ref counting errors.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-20] → [CWE-693] Protection Mechanism Failure</h2>
          <div class="meta">
            <span class="stats">Patterns: 3 • Records: 3</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing browser context CSP checks by bypassing isolated worlds can cause protection bypass.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing browser context CSP checks by bypassing isolated worlds can cause protection bypass.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P2</span>
              <span class="pattern-title">Fixing out-of-bounds access by using scnprintf() can incorrectly zero the buffer, causing device read failures.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing out-of-bounds access by using scnprintf() can incorrectly zero the buffer, causing device read failures.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P3</span>
              <span class="pattern-title">Fixing NUL byte injection by enforcing strict path validation can cause disruption of abstract namespace socket functionality.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing NUL byte injection by enforcing strict path validation can cause disruption of abstract namespace socket functionality.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-20] → [CWE-787] Out-of-bounds Write</h2>
          <div class="meta">
            <span class="stats">Patterns: 3 • Records: 3</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing overflow by bounds checking without dimension validation can cause out-of-bounds writes.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing overflow by bounds checking without dimension validation can cause out-of-bounds writes.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P2</span>
              <span class="pattern-title">Fixing heredoc handling by altering string methods can cause buffer overflow with non-null-terminated strings.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing heredoc handling by altering string methods can cause buffer overflow with non-null-terminated strings.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P3</span>
              <span class="pattern-title">Fixing node-split logic by incorrect &#x27;many&#x27; flag propagation can cause out-of-bounds writes.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing node-split logic by incorrect &#x27;many&#x27; flag propagation can cause out-of-bounds writes.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-20] → [CWE-862] Missing Authorization</h2>
          <div class="meta">
            <span class="stats">Patterns: 3 • Records: 3</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing handler restriction by banning target handler can cause overly restrictive access control, hindering functionality.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing handler restriction by banning target handler can cause overly restrictive access control, hindering functionality.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P2</span>
              <span class="pattern-title">Fixing insecure GID handling by limited RPC checks can cause unchecked GID accesses elsewhere.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing insecure GID handling by limited RPC checks can cause unchecked GID accesses elsewhere.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P3</span>
              <span class="pattern-title">Fixing notification message handling by removing validation can cause unauthorized processing of zero-length messages.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing notification message handling by removing validation can cause unauthorized processing of zero-length messages.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-287] → [CWE-693] Protection Mechanism Failure</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 3</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing authentication by adding strict validation can introduce protection mechanism failures through overly restrictive checks that reject legitimate operations.</span>
              <span class="pattern-count">(3 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing header scrubbing for OIDCUnAuthAction can cause security gaps by omitting other authentication schemes.</li><li>Fixing call number validation by strict enforcement can cause denial of service for legitimate IAX2 communications.</li><li>Fixing call number validation by enforcing full frame checks can cause legitimate calls to be rejected.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-362] → [CWE-833] Deadlock</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 3</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing race conditions by adding locks or synchronization primitives can introduce deadlock when lock ordering is incorrect or locks are used in incompatible contexts.</span>
              <span class="pattern-count">(3 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing a race condition by rescheduling key validation after semaphore acquisition can cause semaphore-induced deadlock.</li><li>Fixing race condition by adding spin_lock can cause deadlocks with other locks.</li><li>Fixing IRQ safety by disabling interrupts can cause deadlocks when locks require interrupts to be enabled.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-399] → [CWE-190] Integer Overflow or Wraparound</h2>
          <div class="meta">
            <span class="stats">Patterns: 3 • Records: 3</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing unsigned to signed conversion can cause undefined behavior due to incorrect shift operations.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing unsigned to signed conversion can cause undefined behavior due to incorrect shift operations.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P2</span>
              <span class="pattern-title">Fixing variable assembly by using &#x27;int&#x27; type can cause integer overflow with large inputs.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing variable assembly by using &#x27;int&#x27; type can cause integer overflow with large inputs.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P3</span>
              <span class="pattern-title">Fixing table loop termination by level checks can cause integer overflow if increment exceeds limit.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing table loop termination by level checks can cause integer overflow if increment exceeds limit.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-399] → [CWE-415] Double Free</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 3</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing resource management issues by changing cleanup timing or adding early cleanup can introduce double free when object lifecycle ownership becomes unclear.</span>
              <span class="pattern-count">(3 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing event dispatch order by delaying node removal can cause unsafe widget updates.</li><li>Fixing page leak by releasing on error can cause double free when header and fragment share a slot.</li><li>Fixing memory leak by early reference drop can cause double free if lifecycle handling is inconsistent.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-415] → [CWE-416] Use After Free</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 3</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing double free by modifying free conditions or adding conditional frees can introduce use-after-free when reference tracking remains incomplete.</span>
              <span class="pattern-count">(3 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing conditional buffer get by removing position check can cause use after free if buffer double-freed.</li><li>Fixing double-free by controlled free calls can cause incorrect persistence and use-after-free errors.</li><li>Fixing use-after-free by conditional free can cause use of an invalid object reference.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-416] → [CWE-119] Improper Restriction of Operations within the Bounds of a Memory Buffer</h2>
          <div class="meta">
            <span class="stats">Patterns: 3 • Records: 3</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing potential crashes by inadequate length checks can cause buffer over-reads.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing potential crashes by inadequate length checks can cause buffer over-reads.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P2</span>
              <span class="pattern-title">Fixing error return check by less-than-zero comparison can cause stack buffer overflows due to incorrect boundary handling.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing error return check by less-than-zero comparison can cause stack buffer overflows due to incorrect boundary handling.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P3</span>
              <span class="pattern-title">Fixing p2m_set_entry() failure checks by crashing on errors can cause crashes due to unhandled misaligned GFN values.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing p2m_set_entry() failure checks by crashing on errors can cause crashes due to unhandled misaligned GFN values.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-416] → [CWE-125] Out-of-bounds Read</h2>
          <div class="meta">
            <span class="stats">Patterns: 3 • Records: 3</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing use-after-free by changing zval references can cause out-of-bounds reads when improperly iterating over XML attributes.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing use-after-free by changing zval references can cause out-of-bounds reads when improperly iterating over XML attributes.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P2</span>
              <span class="pattern-title">Fixing null dereference and UAF by adding checks can cause unchecked array accesses.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing null dereference and UAF by adding checks can cause unchecked array accesses.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P3</span>
              <span class="pattern-title">Fixing excessive bounds checks by removing conditions can cause unchecked out-of-bounds reads.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing excessive bounds checks by removing conditions can cause unchecked out-of-bounds reads.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-416] → [CWE-415] Double Free</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 3</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing use-after-free by modifying object lifecycle management can introduce double free when deallocation paths are duplicated or incomplete.</span>
              <span class="pattern-count">(3 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing re-entrancy via scoped_ptr can cause object double deletion if destructed mid-load-cancellation.</li><li>Fixing premature audio handler deletion by conditional state checks can cause duplicate deallocation risks.</li><li>Fixing use-after-free by nullifying pointers can cause double free due to incomplete handling of linked list pointers.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-416] → [CWE-672] Operation on a Resource after Expiration or Release</h2>
          <div class="meta">
            <span class="stats">Patterns: 3 • Records: 3</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing UAF by deferred free can cause resource misuse due to shared reference tracker.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing UAF by deferred free can cause resource misuse due to shared reference tracker.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P2</span>
              <span class="pattern-title">Fixing use-after-free by storing pointer value can cause improper handling of removed sockets.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing use-after-free by storing pointer value can cause improper handling of removed sockets.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P3</span>
              <span class="pattern-title">Fixing register optimization by variable marking can cause resource mishandling in exception stack exhaustion.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing register optimization by variable marking can cause resource mishandling in exception stack exhaustion.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-416] → [CWE-843] Access of Resource Using Incompatible Type (&#x27;Type Confusion&#x27;)</h2>
          <div class="meta">
            <span class="stats">Patterns: 3 • Records: 3</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing use-after-free by moving cleanup to free_user can cause sleep-in-atomic due to improper context handling.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing use-after-free by moving cleanup to free_user can cause sleep-in-atomic due to improper context handling.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P2</span>
              <span class="pattern-title">Fixing use-after-free by setting highest_sack to new skbs can cause type confusion in skb pointer management.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing use-after-free by setting highest_sack to new skbs can cause type confusion in skb pointer management.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P3</span>
              <span class="pattern-title">Fixing argument copy logic by altering conditions can cause type confusion in resource access.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing argument copy logic by altering conditions can cause type confusion in resource access.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-476] → [CWE-401] Missing Release of Memory after Effective Lifetime</h2>
          <div class="meta">
            <span class="stats">Patterns: 3 • Records: 3</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P2</span>
              <span class="pattern-title">Fixing tun device name validation by allowing positive return can cause a memory leak in tx_array cleanup.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing tun device name validation by allowing positive return can cause a memory leak in tx_array cleanup.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P3</span>
              <span class="pattern-title">Fixing serialization handling by setting data to UNDEF can cause memory leaks if not properly destructed.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing serialization handling by setting data to UNDEF can cause memory leaks if not properly destructed.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing NULL dereference with checks/modifications but omitting cleanup on error paths causes memory leaks.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing error pointer checks by immediate returns can cause resource leaks when bypassing cleanup code.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-476] → [CWE-665] Improper Initialization</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 3</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing null pointer dereference by adding checks can cause incorrect initialization when related state variables or flags are not properly initialized.</span>
              <span class="pattern-count">(3 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing element inconsistency checks by relying on uninitialized frame markers can cause false positive rejections of valid files.</li><li>Fixing chroma processing by format-specific checks can cause incomplete initialization for other prediction paths.</li><li>Fixing uninitialized state usage by flag checks can cause related state initialization paths to be overlooked.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-476] → [CWE-670] Always-Incorrect Control Flow Implementation</h2>
          <div class="meta">
            <span class="stats">Patterns: 3 • Records: 3</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing null-dereference by incomplete validation can cause crashes from missing bulk-out endpoint checks.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing null-dereference by incomplete validation can cause crashes from missing bulk-out endpoint checks.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P2</span>
              <span class="pattern-title">Fixing emulation by moving breakpoint handling can cause improper instruction retries when shadow unprotect fails.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing emulation by moving breakpoint handling can cause improper instruction retries when shadow unprotect fails.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P3</span>
              <span class="pattern-title">Fixing NULL checks in optional GPIO functions by using IS_ERR_OR_NULL can cause false error handling for valid NULL returns.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing NULL checks in optional GPIO functions by using IS_ERR_OR_NULL can cause false error handling for valid NULL returns.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-703] → [CWE-476] NULL Pointer Dereference</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 3</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing improper error checking by adding validation can introduce null pointer dereference when checks miss specific null conditions or fields.</span>
              <span class="pattern-count">(3 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing USB descriptor validation by checking endpoint count can cause undetected NULL dereference.</li><li>Fixing mount propagation logic by incorrect termination condition can cause unhandled NULL pointer dereference.</li><li>Fixing NULL interface checks by adding general NULL checks can cause missed specific NULL fields leading to dereferences.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-787] → [CWE-126] Buffer Over-read</h2>
          <div class="meta">
            <span class="stats">Patterns: 3 • Records: 3</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing out-of-bounds issues by overly strict checks can cause valid configurations to be rejected.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing out-of-bounds issues by overly strict checks can cause valid configurations to be rejected.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P2</span>
              <span class="pattern-title">Fixing buffer allocation without bounds checking can cause buffer over-read in string handling.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing buffer allocation without bounds checking can cause buffer over-read in string handling.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P3</span>
              <span class="pattern-title">Fixing hash table overflow by bucket checks can cause PT_DYNAMIC segments to be processed without bounds validation.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing hash table overflow by bucket checks can cause PT_DYNAMIC segments to be processed without bounds validation.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-787] → [CWE-134] Use of Externally-Controlled Format String</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 3</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing out-of-bounds write by modifying string handling or error messages can introduce format string vulnerabilities when user input is placed in format specifiers.</span>
              <span class="pattern-count">(3 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing bounds check issues by adding exception messages can cause format string vulnerabilities.</li><li>Fixing buffer overflow by removing format specifier can cause format string vulnerabilities.</li><li>Fixing buffer overflow by using snprintf can cause improper handling of localized number formats.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-787] → [CWE-400] Uncontrolled Resource Consumption</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 3</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing out-of-bounds write by adding validation can introduce resource exhaustion when limits are too permissive or computational complexity remains unchecked.</span>
              <span class="pattern-count">(3 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing negative gamma inputs by naive pow() usage can cause computational inefficiencies prone to exploitation.</li><li>Fixing channel count overflow by broad limits can cause excessive resource usage with oversized channel definitions.</li><li>Fixing output length by post-encoding checks can cause excessive CPU usage on large inputs.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-119] → [CWE-129] Improper Validation of Array Index</h2>
          <div class="meta">
            <span class="stats">Patterns: 2 • Records: 2</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing out-of-bounds by coordinate division can cause incorrect subsample address calculations.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing out-of-bounds by coordinate division can cause incorrect subsample address calculations.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P2</span>
              <span class="pattern-title">Fixing buffer overflow reads by adjusting boundary checks can cause improper validation of buffer boundaries.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing buffer overflow reads by adjusting boundary checks can cause improper validation of buffer boundaries.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-119] → [CWE-188] Reliance on Data/Memory Layout</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 2</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing buffer issues by changing data handling can introduce endianness problems.</span>
              <span class="pattern-count">(2 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing initresp parsing by manual bit shifts can cause endianness issues.</li><li>Fixing USB stack allocation by heap allocation can cause endianness issues with different firmware protocols.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-119] → [CWE-191] Integer Underflow (Wrap or Wraparound)</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 2</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing buffer overflow by adjusting bounds checking can introduce integer underflow in length calculations or pointer arithmetic.</span>
              <span class="pattern-count">(2 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing heap overflow by adjusting bounds checking can cause underflow vulnerabilities in similar length calculations.</li><li>Fixing signature length bounds by adding checks can cause integer underflow due to incorrect pointer arithmetic.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-119] → [CWE-193] Off-by-one Error</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 2</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing buffer boundaries can introduce off-by-one errors in pointer or length calculations.</span>
              <span class="pattern-count">(2 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing buffer boundary by early returns can cause incorrect end pointer calculations.</li><li>Fixing buffer access by pointer validation can cause off-by-one errors if length calculations are faulty.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-119] → [CWE-197] Numeric Truncation Error</h2>
          <div class="meta">
            <span class="stats">Patterns: 2 • Records: 2</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing packet length by treating as unsigned can cause misinterpretation of negative input.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing packet length by treating as unsigned can cause misinterpretation of negative input.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P2</span>
              <span class="pattern-title">Fixing buffer overflow by type reduction can cause integer truncation and bypass of large bounds checks.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing buffer overflow by type reduction can cause integer truncation and bypass of large bounds checks.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-119] → [CWE-20] Improper Input Validation</h2>
          <div class="meta">
            <span class="stats">Patterns: 2 • Records: 2</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing global parameter change by parameter checks can cause improper validation of slice dimensions.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing global parameter change by parameter checks can cause improper validation of slice dimensions.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P2</span>
              <span class="pattern-title">Fixing buffer overflow by extremely large value checks can cause insufficient boundary validation for PDF/A-1 specifications.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing buffer overflow by extremely large value checks can cause insufficient boundary validation for PDF/A-1 specifications.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-119] → [CWE-456] Missing Initialization of a Variable</h2>
          <div class="meta">
            <span class="stats">Patterns: 2 • Records: 2</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing argument checks by introducing subarray gathers can cause usage of uninitialized variables.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing argument checks by introducing subarray gathers can cause usage of uninitialized variables.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P2</span>
              <span class="pattern-title">Fixing JPEG processing with C++ exceptions can cause incorrect error handling with uninitialized control flow paths.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing JPEG processing with C++ exceptions can cause incorrect error handling with uninitialized control flow paths.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-119] → [CWE-665] Improper Initialization</h2>
          <div class="meta">
            <span class="stats">Patterns: 2 • Records: 2</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing buffer overflow by adding dimension checks can cause similar uncorrected issues in other functions.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing buffer overflow by adding dimension checks can cause similar uncorrected issues in other functions.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P2</span>
              <span class="pattern-title">Fixing error handling by clearing and resetting fields can cause uninitialized variables leading to undefined behavior.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing error handling by clearing and resetting fields can cause uninitialized variables leading to undefined behavior.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-122] → [CWE-190] Integer Overflow or Wraparound</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 2</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing heap overflow by adding boundary checks can introduce integer overflow in size calculations.</span>
              <span class="pattern-count">(2 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing read position update by reordering increment can cause integer overflow when handling audio chunks.</li><li>Fixing buffer overflow by boundary checks can cause integer overflow if arithmetic operations exceed limit.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-125] → [CWE-122] Heap-based Buffer Overflow</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 2</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing buffer over-read by adjusting size calculations can cause heap overflow due to inadequate allocation.</span>
              <span class="pattern-count">(2 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing buffer overflow by adjusting multiplier can cause memory corruption due to inadequate size calculation.</li><li>Fixing buffer overflow by incrementing allocation size can cause insufficient allocations leading to overflows.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-125] → [CWE-131] Incorrect Calculation of Buffer Size</h2>
          <div class="meta">
            <span class="stats">Patterns: 2 • Records: 2</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing number limit by capping can cause incorrect buffer handling when actual reads mismatch recorded amounts.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing number limit by capping can cause incorrect buffer handling when actual reads mismatch recorded amounts.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P2</span>
              <span class="pattern-title">Fixing buffer overflow by using uniform components can cause underallocation for components with variable sizes.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing buffer overflow by using uniform components can cause underallocation for components with variable sizes.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-125] → [CWE-200] Exposure of Sensitive Information to an Unauthorized Actor</h2>
          <div class="meta">
            <span class="stats">Patterns: 2 • Records: 2</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing index usage by converting indices to unsigned can cause unintended exposure of sensitive headers.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing index usage by converting indices to unsigned can cause unintended exposure of sensitive headers.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P2</span>
              <span class="pattern-title">Fixing crash issues by commenting out memory operations can cause unintended data exposure through unguarded function calls.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing crash issues by commenting out memory operations can cause unintended data exposure through unguarded function calls.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-125] → [CWE-401] Improper Release of Memory Before Removing Last Reference (&#x27;Memory Leak&#x27;)</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 2</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing buffer over-read by modifying control flow or adding early exits can cause memory leaks when cleanup code is bypassed in error paths.</span>
              <span class="pattern-count">(2 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing error-handling by simplifying status checks can cause memory leaks if resources are not correctly released.</li><li>Fixing tag name lookup with a hash table can cause memory leaks when tables are not freed.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-125] → [CWE-415] Double Free</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 2</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing buffer over-read by reordering cleanup operations can introduce double free on error paths.</span>
              <span class="pattern-count">(2 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing image dimension correction by reordering cleanup can cause memory double-free on certain error paths.</li><li>Fixing memory leaks by freeing resources early can cause double-free when paths converge post-loop.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-125] → [CWE-416] Use After Free</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 2</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing buffer over-read by adding checks can introduce use-after-free through incomplete pointer management.</span>
              <span class="pattern-count">(2 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing heap buffer overflow by adding safety checks can cause use-after-free during packet memory management.</li><li>Fixing use-after-free by checking deletion success can cause new use-after-free via incomplete pointer management.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-125] → [CWE-665] Improper Initialization</h2>
          <div class="meta">
            <span class="stats">Patterns: 2 • Records: 2</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing one oobread with a length check can cause other similar issues to remain unguarded.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing one oobread with a length check can cause other similar issues to remain unguarded.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P2</span>
              <span class="pattern-title">Fixing memory allocation size by using MagickMax can cause uninitialized memory usage.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing memory allocation size by using MagickMax can cause uninitialized memory usage.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-125] → [CWE-672] Operation on a Resource after Expiration or Release</h2>
          <div class="meta">
            <span class="stats">Patterns: 2 • Records: 2</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing buffer overflows by using size checks can cause erroneous resource management leading to memory leaks.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing buffer overflows by using size checks can cause erroneous resource management leading to memory leaks.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P2</span>
              <span class="pattern-title">Fixing out-of-bounds access by simple index checks can cause missed memory safety checks elsewhere.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing out-of-bounds access by simple index checks can cause missed memory safety checks elsewhere.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-125] → [CWE-703] Improper Check or Handling of Exceptional Conditions</h2>
          <div class="meta">
            <span class="stats">Patterns: 2 • Records: 2</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing integer overflow by SafeMul/SafeAdd can cause incomplete error handling in Inflate/Read operations.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing integer overflow by SafeMul/SafeAdd can cause incomplete error handling in Inflate/Read operations.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P2</span>
              <span class="pattern-title">Fixing out-of-bounds read by safer access can cause improper handling of invalid directory entries.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing out-of-bounds read by safer access can cause improper handling of invalid directory entries.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-125] → [CWE-788] Access of Memory Location After End of Buffer</h2>
          <div class="meta">
            <span class="stats">Patterns: 2 • Records: 2</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing buffer tracking via &#x27;extent&#x27; can cause memory access out of bounds when checks are misordered.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing buffer tracking via &#x27;extent&#x27; can cause memory access out of bounds when checks are misordered.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P2</span>
              <span class="pattern-title">Fixing stack overflow by adding size checks can cause buffer overflow if size checks use incorrect buffer size.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing stack overflow by adding size checks can cause buffer overflow if size checks use incorrect buffer size.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-189] → [CWE-125] Out-of-bounds Read</h2>
          <div class="meta">
            <span class="stats">Patterns: 2 • Records: 2</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing pointer wraparound by incomplete early checks can cause buffer overreads due to incorrect bounds validation order.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing pointer wraparound by incomplete early checks can cause buffer overreads due to incorrect bounds validation order.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P2</span>
              <span class="pattern-title">Fixing boundary condition by altering comparison operator may cause out-of-bounds access.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing boundary condition by altering comparison operator may cause out-of-bounds access.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-189] → [CWE-20] Improper Input Validation</h2>
          <div class="meta">
            <span class="stats">Patterns: 2 • Records: 2</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing zero cwnd issues by skipping PRR operations can cause bogus DSACK handling through unvalidated input ranges.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing zero cwnd issues by skipping PRR operations can cause bogus DSACK handling through unvalidated input ranges.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P2</span>
              <span class="pattern-title">Fixing empty string handling by removing header checks can cause malicious inputs to pass improperly validated.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing empty string handling by removing header checks can cause malicious inputs to pass improperly validated.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-189] → [CWE-362] Concurrent Execution using Shared Resource with Improper Synchronization (&#x27;Race Condition&#x27;)</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 2</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing numerical errors by adding checks without proper synchronization can introduce race conditions.</span>
              <span class="pattern-count">(2 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing iov_count overflow by limiting without sync can introduce race conditions in buffer handling.</li><li>Fixing control permission issues by modifying logic can cause race condition vulnerabilities without proper synchronization.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-189] → [CWE-416] Use After Free</h2>
          <div class="meta">
            <span class="stats">Patterns: 2 • Records: 2</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing synchronous unload by guards can cause resource clearing omissions.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing synchronous unload by guards can cause resource clearing omissions.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P2</span>
              <span class="pattern-title">Fixing special character handling can cause use-after-free errors if node types and allocation issues are unchecked.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing special character handling can cause use-after-free errors if node types and allocation issues are unchecked.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-190] → [CWE-120] Buffer Copy without Checking Size of Input (&#x27;Classic Buffer Overflow&#x27;)</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 2</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing integer overflow by modifying bounds checks can introduce buffer copy vulnerabilities.</span>
              <span class="pattern-count">(2 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing integer overflow by validating prop_count can cause insufficient bounds checks and lead to buffer overflow in unpacking functions.</li><li>Fixing overflow checks by ignoring length constraints can cause buffer overflows in memory allocation.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-190] → [CWE-125] Out-of-bounds Read</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 2</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing integer overflow by adjusting bounds can introduce out-of-bounds read vulnerabilities.</span>
              <span class="pattern-count">(2 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing integer overflow by modifying bounds checks can cause improper range checks leading to out-of-bounds reads.</li><li>Fixing phar manifest entry parsing by adjusting offsets can cause out-of-bounds read leading to segmentation fault.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-190] → [CWE-401] Improper Release of Memory Before Removing Last Reference (&#x27;Memory Leak&#x27;)</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 2</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing integer overflow by adding early returns can cause memory leaks when cleanup is bypassed.</span>
              <span class="pattern-count">(2 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing incomplete EOF checks by early breaks can cause memory leaks if not all allocations are freed.</li><li>Fixing integer overflow by returning NULL can cause memory leaks due to missed deallocation paths.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-190] → [CWE-754] Improper Check for Unusual or Exceptional Conditions</h2>
          <div class="meta">
            <span class="stats">Patterns: 2 • Records: 2</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing offset overflow by length cap can cause valid packet rejection.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing offset overflow by length cap can cause valid packet rejection.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P2</span>
              <span class="pattern-title">Fixing addition overflows by Safe::add() can cause overly strict boundary checks and deny legitimate data.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing addition overflows by Safe::add() can cause overly strict boundary checks and deny legitimate data.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-20] → [CWE-116] Improper Encoding or Escaping of Output</h2>
          <div class="meta">
            <span class="stats">Patterns: 2 • Records: 2</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing UTF-8 validation by replacing invalid values can cause improper input sanitization.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing UTF-8 validation by replacing invalid values can cause improper input sanitization.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P2</span>
              <span class="pattern-title">Fixing option injection by blocking dashes can cause newline handling oversight in URL validation.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing option injection by blocking dashes can cause newline handling oversight in URL validation.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-20] → [CWE-295] Improper Certificate Validation</h2>
          <div class="meta">
            <span class="stats">Patterns: 2 • Records: 2</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing user input PSTATE by system validation can cause improper handling in asymmetric CPU setups.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing user input PSTATE by system validation can cause improper handling in asymmetric CPU setups.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P2</span>
              <span class="pattern-title">Fixing payload decryption by null return on empty payloads can cause MIC authentication checks to be skipped.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing payload decryption by null return on empty payloads can cause MIC authentication checks to be skipped.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-20] → [CWE-674] Uncontrolled Recursion</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 2</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing input validation incompletely can leave uncontrolled recursion vulnerabilities.</span>
              <span class="pattern-count">(2 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing uninitialized values by improperly handling environments can cause stack overflow through uncontrolled recursive nesting.</li><li>Fixing unsecured entity fetching by partial checks can cause recursion-based attacks via entity expansion.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-20] → [CWE-704] Incorrect Type Conversion or Cast</h2>
          <div class="meta">
            <span class="stats">Patterns: 2 • Records: 2</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing integer range check by unsafe type casting can cause undefined behavior due to strict aliasing violations.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing integer range check by unsafe type casting can cause undefined behavior due to strict aliasing violations.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P2</span>
              <span class="pattern-title">Fixing BCD handling by new digit conversion can cause incorrect digit interpretation due to wrong default mapping.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing BCD handling by new digit conversion can cause incorrect digit interpretation due to wrong default mapping.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-20] → [CWE-835] Loop with Unreachable Exit Condition (&#x27;Infinite Loop&#x27;)</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 2</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing input validation by modifying checks can introduce infinite loop conditions.</span>
              <span class="pattern-count">(2 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing rate-limiting parameters by using non-monotonic clocks can cause bypassing limits due to time adjustments.</li><li>Fixing offset usage by changing test placement can cause infinite loops on malformed packets.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-20] → [CWE-863] Incorrect Authorization</h2>
          <div class="meta">
            <span class="stats">Patterns: 2 • Records: 2</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing DFS referral by removing prefixpath check can cause invalid path access due to insufficient path validation.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing DFS referral by removing prefixpath check can cause invalid path access due to insufficient path validation.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P2</span>
              <span class="pattern-title">Fixing mlock count decrement by adjusting &#x27;allowed&#x27; handling can cause incorrect authorization on memory locking.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing mlock count decrement by adjusting &#x27;allowed&#x27; handling can cause incorrect authorization on memory locking.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-200] → [CWE-209] Information Exposure Through an Error Message</h2>
          <div class="meta">
            <span class="stats">Patterns: 2 • Records: 2</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing zeroing of allocated buffers by clearing specific paths can cause incomplete zeroing, exposing memory.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing zeroing of allocated buffers by clearing specific paths can cause incomplete zeroing, exposing memory.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P2</span>
              <span class="pattern-title">Fixing ECDSA timing attack with blinding can cause point addition errors leading to exposure.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing ECDSA timing attack with blinding can cause point addition errors leading to exposure.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-200] → [CWE-362] Concurrent Execution using Shared Resource with Improper Synchronization (&#x27;Race Condition&#x27;)</h2>
          <div class="meta">
            <span class="stats">Patterns: 2 • Records: 2</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing info leak with checks/initialization but incomplete atomicity (missing locks/improper locking) creates races under concurrency.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing mount namespace security by adding seqlock can cause race conditions in tree operations.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P6</span>
              <span class="pattern-title">Fixing file permission by using open() with limited flags can cause race condition vulnerabilities.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing file permission by using open() with limited flags can cause race condition vulnerabilities.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-200] → [CWE-457] Use of Uninitialized Variable</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 2</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing information exposure by memory initialization can be negated by subsequent changes that reintroduce uninitialized memory.</span>
              <span class="pattern-count">(2 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing struct leakage by improper memset use can cause partial uninitialized memory exposure.</li><li>Fixing an info leak by initializing memory can cause re-exposure by removing that initialization.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-200] → [CWE-732] Incorrect Permission Assignment for Critical Resource</h2>
          <div class="meta">
            <span class="stats">Patterns: 2 • Records: 2</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing public-to-private socket transition by strict permissions can cause failure in unprivileged execution paths.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing public-to-private socket transition by strict permissions can cause failure in unprivileged execution paths.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P2</span>
              <span class="pattern-title">Fixing file permission by umask(0077) can cause security bypass on unsupported systems.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing file permission by umask(0077) can cause security bypass on unsupported systems.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-22] → [CWE-732] Incorrect Permission Assignment for Critical Resource</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 2</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing path traversal can introduce incorrect file permissions on extracted or created files.</span>
              <span class="pattern-count">(2 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing permission removal by widening file system denials can cause excessive restrictions, breaking existing configurations.</li><li>Fixing path traversal by limiting extraction can cause permission retention on file replacements.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-264] → [CWE-119] Improper Restriction of Operations within the Bounds of a Memory Buffer</h2>
          <div class="meta">
            <span class="stats">Patterns: 2 • Records: 2</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing DMA executable permissions by using PAGE_KERNEL can cause improper memory access.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing DMA executable permissions by using PAGE_KERNEL can cause improper memory access.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P2</span>
              <span class="pattern-title">Refactoring scatterlist handling by separating concerns can cause buffer boundary mismanagement in sg iteration.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Refactoring scatterlist handling by separating concerns can cause buffer boundary mismanagement in sg iteration.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-264] → [CWE-20] Improper Input Validation</h2>
          <div class="meta">
            <span class="stats">Patterns: 2 • Records: 2</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing URL serialization by partial validation can cause inconsistent handling of malicious URLs.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing URL serialization by partial validation can cause inconsistent handling of malicious URLs.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P2</span>
              <span class="pattern-title">Fixing access control via paranoid level change can cause improper validation of callchain inputs.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing access control via paranoid level change can cause improper validation of callchain inputs.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-264] → [CWE-269] Improper Privilege Management</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 2</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing permission checks by modifying UID/GID validation can introduce privilege escalation vulnerabilities.</span>
              <span class="pattern-count">(2 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing fsuid checks by replacing them with euid can cause privilege escalation if fsuid is manipulated.</li><li>Fixing id_map capability checks by enforcing both opener and writer caps can allow bypass in uid 0 mappings.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-264] → [CWE-362] Concurrent Execution using Shared Resource with Improper Synchronization (&#x27;Race Condition&#x27;)</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 2</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing permissions/privilege vulnerabilities by adding access controls or locks can introduce race conditions when synchronization is incomplete.</span>
              <span class="pattern-count">(2 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing information leak by access checks can cause race conditions in privileged data gathering.</li><li>Fixing event context changes by adding locks can cause race conditions in context installation.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-264] → [CWE-703] Improper Check or Handling of Exceptional Conditions</h2>
          <div class="meta">
            <span class="stats">Patterns: 2 • Records: 2</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing RIP canonical checks by modifying CS can cause inconsistent state during far jump failures.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing RIP canonical checks by modifying CS can cause inconsistent state during far jump failures.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P2</span>
              <span class="pattern-title">Fixing file cap permissions by clearing personality flags can cause mismanagement of setgid interpreter capabilities.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing file cap permissions by clearing personality flags can cause mismanagement of setgid interpreter capabilities.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-264] → [CWE-843] Access of Resource Using Incompatible Type (&#x27;Type Confusion&#x27;)</h2>
          <div class="meta">
            <span class="stats">Patterns: 2 • Records: 2</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing RIP error handling with incorrect non-canonical checks can cause type confusion in address space.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing RIP error handling with incorrect non-canonical checks can cause type confusion in address space.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P2</span>
              <span class="pattern-title">Fixing page table walk with compact semantics can cause misinterpretation of page types due to bit overlap.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing page table walk with compact semantics can cause misinterpretation of page types due to bit overlap.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-264] → [CWE-862] Missing Authorization</h2>
          <div class="meta">
            <span class="stats">Patterns: 2 • Records: 2</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing policy checks by ignoring partial block can cause unauthorized access to multiple devices.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing policy checks by ignoring partial block can cause unauthorized access to multiple devices.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P2</span>
              <span class="pattern-title">Fixing pid spoof defense by checking current pidns can cause authorization checks in wrong namespace.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing pid spoof defense by checking current pidns can cause authorization checks in wrong namespace.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-276] → [CWE-732] Incorrect Permission Assignment for Critical Resource</h2>
          <div class="meta">
            <span class="stats">Patterns: 2 • Records: 2</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing raw socket creation by insufficient namespace checks can cause unauthorized access in containerized environments.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing raw socket creation by insufficient namespace checks can cause unauthorized access in containerized environments.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P2</span>
              <span class="pattern-title">Fixing conditionally incorrect chmod can cause excessive permission changes on unintended files.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing conditionally incorrect chmod can cause excessive permission changes on unintended files.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-287] → [CWE-670] Always-Incorrect Control Flow Implementation</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 2</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing authentication by adding strict validation can cause logic errors that reject legitimate operations.</span>
              <span class="pattern-count">(2 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing call number validation with strict checks can cause denial of service by dropping legitimate packets.</li><li>Fixing call number spoofing by broad validation can cause legitimate calls to fail due to over-validation.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-287] → [CWE-754] Improper Check for Unusual or Exceptional Conditions</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 2</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing authentication by adding strict checks can cause denial of service by rejecting legitimate requests.</span>
              <span class="pattern-count">(2 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing destination call number checks by stringent validation can cause denial of service through blocked legitimate calls.</li><li>Fixing call number spoofing by over-checking full frames can cause failure in legitimate connection establishment.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-362] → [CWE-269] Improper Privilege Management</h2>
          <div class="meta">
            <span class="stats">Patterns: 2 • Records: 2</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing race condition by mutex lock can cause improper UID/GID translation in idmapped mounts.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing race condition by mutex lock can cause improper UID/GID translation in idmapped mounts.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P2</span>
              <span class="pattern-title">Fixing container support by exploring root directories can cause unauthorized file access via manipulated process roots.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing container support by exploring root directories can cause unauthorized file access via manipulated process roots.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-362] → [CWE-367] Time-of-check Time-of-use (TOCTOU) Race Condition</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 2</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing race conditions by adding locks can introduce new TOCTOU issues if checks remain separate from operations.</span>
              <span class="pattern-count">(2 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing race in event channel handling by using locks can cause TOCTOU race on row initialization.</li><li>Fixing TLB flush timing by early rmap removal can cause inconsistent page state observations.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-362] → [CWE-665] Improper Initialization</h2>
          <div class="meta">
            <span class="stats">Patterns: 2 • Records: 2</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing race condition by replacing BUG_ON can cause double unlock or double free vulnerabilities.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing race condition by replacing BUG_ON can cause double unlock or double free vulnerabilities.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P2</span>
              <span class="pattern-title">Fixing null pointer dereference by checking pointers can cause state inconsistencies when error returns are ignored.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing null pointer dereference by checking pointers can cause state inconsistencies when error returns are ignored.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-362] → [CWE-672] Operation on a Resource after Expiration or Release</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 2</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing race conditions by adding synchronization can introduce incorrect resource lifecycle management.</span>
              <span class="pattern-count">(2 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing double unlink by conditionally using list_del_init can cause last active element to remain in list.</li><li>Fixing line discipline usage by mutexes can cause improper external usage checks.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-399] → [CWE-404] Improper Resource Shutdown or Release</h2>
          <div class="meta">
            <span class="stats">Patterns: 2 • Records: 2</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing buffer overflow by dynamic allocation can cause memory leaks of crypto key material on error.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing buffer overflow by dynamic allocation can cause memory leaks of crypto key material on error.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P2</span>
              <span class="pattern-title">Fixing double-free by restructuring cleanup logic can cause improper resource release on error paths.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing double-free by restructuring cleanup logic can cause improper resource release on error paths.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-399] → [CWE-667] Improper Locking</h2>
          <div class="meta">
            <span class="stats">Patterns: 2 • Records: 2</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing IP option handling by compiling IP options can cause incorrect packet processing.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing IP option handling by compiling IP options can cause incorrect packet processing.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P2</span>
              <span class="pattern-title">Fixing crash by adding control block check can cause improper reuse of linked event channels.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing crash by adding control block check can cause improper reuse of linked event channels.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-399] → [CWE-703] Improper Check or Handling of Exceptional Conditions</h2>
          <div class="meta">
            <span class="stats">Patterns: 2 • Records: 2</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing function refactoring by consolidating parsing can lead to improper error code setting in constraints validation.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing function refactoring by consolidating parsing can lead to improper error code setting in constraints validation.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P2</span>
              <span class="pattern-title">Fixing infinite loop by forward progress checks can cause malformed headers to be processed as valid.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing infinite loop by forward progress checks can cause malformed headers to be processed as valid.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-399] → [CWE-787] Out-of-bounds Write</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 2</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing resource management by changing memory handling can introduce out-of-bounds write vulnerabilities.</span>
              <span class="pattern-count">(2 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing driver issue by disabling PBO path can cause improper memory access on resolution changes.</li><li>Fixing text update without triggering layout can cause heap-buffer-overflow due to improper boundary checks.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-400] → [CWE-190] Integer Overflow or Wraparound</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 2</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing resource exhaustion by adding size calculations can introduce integer overflow in arithmetic operations.</span>
              <span class="pattern-count">(2 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing pad calculation using ssize_t cast can cause integer overflow in padding computation.</li><li>Fixing buffer overflow with arithmetic checks can cause integer overflows due to improper bounds calculation.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-400] → [CWE-703] Improper Check or Handling of Exceptional Conditions</h2>
          <div class="meta">
            <span class="stats">Patterns: 2 • Records: 2</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing connection leaks by removing partial message handling can cause denial of service.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing connection leaks by removing partial message handling can cause denial of service.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P2</span>
              <span class="pattern-title">Fixing chain rebinding by returning EINVAL can cause unbound chains through commit phase oversight.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing chain rebinding by returning EINVAL can cause unbound chains through commit phase oversight.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-401] → [CWE-672] Operation on a Resource after Expiration or Release</h2>
          <div class="meta">
            <span class="stats">Patterns: 2 • Records: 2</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing some memory leaks by adding cleanup actions can cause other allocations to remain unreleased on new error paths.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing some memory leaks by adding cleanup actions can cause other allocations to remain unreleased on new error paths.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P2</span>
              <span class="pattern-title">Fixing memory leak by a missing check can cause resource use after errors.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing memory leak by a missing check can cause resource use after errors.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-415] → [CWE-362] Concurrent Execution using Shared Resource with Improper Synchronization (&#x27;Race Condition&#x27;)</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 2</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing double free by refactoring resource management can introduce race conditions in cleanup.</span>
              <span class="pattern-count">(2 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing race conditions by checking waitqueues can cause insufficient synchronization due to incorrect socket handling.</li><li>Fixing double free by refactoring device registration can cause race conditions in resource cleanup.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-416] → [CWE-20] Improper Input Validation</h2>
          <div class="meta">
            <span class="stats">Patterns: 2 • Records: 2</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing error type mismatches by switching to input validation can cause missing checks for certain parameters.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing error type mismatches by switching to input validation can cause missing checks for certain parameters.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P2</span>
              <span class="pattern-title">Fixing use-after-free by adding input checks can cause overly restrictive input validation.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing use-after-free by adding input checks can cause overly restrictive input validation.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-416] → [CWE-401] Memory Leak</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 2</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing use-after-free by removing cleanup/altering refcounts without corresponding decrements causes memory leaks.</span>
              <span class="pattern-count">(2 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing use-after-free by removing put_device can cause memory leaks.</li><li>Fixing UAF bugs by refcount increments without corresponding decrements can cause reference count leaks.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-416] → [CWE-401] Improper Release of Memory Before Removing Last Reference</h2>
          <div class="meta">
            <span class="stats">Patterns: 2 • Records: 2</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P2</span>
              <span class="pattern-title">Fixing SIGSEGV by checking ent-&gt;data can cause use-after-free due to improper memory initialization.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing SIGSEGV by checking ent-&gt;data can cause use-after-free due to improper memory initialization.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P3</span>
              <span class="pattern-title">Fixing trivial equation checks by unguarded skips can cause memory leaks due to incomplete cleanup.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing trivial equation checks by unguarded skips can cause memory leaks due to incomplete cleanup.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-416] → [CWE-693] Protection Mechanism Failure</h2>
          <div class="meta">
            <span class="stats">Patterns: 2 • Records: 2</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing struct pointer handling by resetting fields to NULL can cause improper handling of unnamed set elements.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing struct pointer handling by resetting fields to NULL can cause improper handling of unnamed set elements.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P2</span>
              <span class="pattern-title">Fixing request flag handling by removing cmd_flags manipulation can cause incorrect operation permissions being set.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing request flag handling by removing cmd_flags manipulation can cause incorrect operation permissions being set.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-416] → [CWE-787] Out-of-bounds Write</h2>
          <div class="meta">
            <span class="stats">Patterns: 2 • Records: 2</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing shared buffer references by copying can cause unchecked data writes exceeding allocated buffer size.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing shared buffer references by copying can cause unchecked data writes exceeding allocated buffer size.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P2</span>
              <span class="pattern-title">Fixing PFNs handling by incorrect physical address assumptions can cause arbitrary memory writes.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing PFNs handling by incorrect physical address assumptions can cause arbitrary memory writes.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-476] → [CWE-121] Stack-based Buffer Overflow</h2>
          <div class="meta">
            <span class="stats">Patterns: 2 • Records: 2</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing NULL pointer dereference by adding incomplete checks can cause stack-based buffer overflow.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing NULL pointer dereference by adding incomplete checks can cause stack-based buffer overflow.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P2</span>
              <span class="pattern-title">Fixing NULL dereference by adding checks can cause unaligned access due to incorrect type handling.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing NULL dereference by adding checks can cause unaligned access due to incorrect type handling.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-476] → [CWE-20] Improper Input Validation</h2>
          <div class="meta">
            <span class="stats">Patterns: 2 • Records: 2</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing e_shoff validation by enforcing checks can cause bypasses in non-compression contexts.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing e_shoff validation by enforcing checks can cause bypasses in non-compression contexts.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P2</span>
              <span class="pattern-title">Fixing NULL dereference by simplifying checks can cause inadequate LUN validation.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing NULL dereference by simplifying checks can cause inadequate LUN validation.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-476] → [CWE-672] Operation on a Resource after Expiration or Release</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 2</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing null pointer dereference by adding checks can introduce resource management errors when checks are incomplete.</span>
              <span class="pattern-count">(2 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing NULL pointer checks by adding incomplete checks can cause latent dereferences in other code paths.</li><li>Fixing integer handling by converting to NULL can cause unhandled collated expressions to operate on released resources.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-476] → [CWE-704] Incorrect Type Conversion or Cast</h2>
          <div class="meta">
            <span class="stats">Patterns: 2 • Records: 2</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing PREAUTH handling by modifying enums can cause type confusion with security implications.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing PREAUTH handling by modifying enums can cause type confusion with security implications.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P2</span>
              <span class="pattern-title">Fixing NULL pointer dereference by using incorrect comparison can cause valid pointers to be incorrectly rejected.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing NULL pointer dereference by using incorrect comparison can cause valid pointers to be incorrectly rejected.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-476] → [CWE-843] Access of Resource Using Incompatible Type (&#x27;Type Confusion&#x27;)</h2>
          <div class="meta">
            <span class="stats">Patterns: 2 • Records: 2</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing NULL dereference by checking EC_Normal can cause type confusion without proper type validation.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing NULL dereference by checking EC_Normal can cause type confusion without proper type validation.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P2</span>
              <span class="pattern-title">Fixing data handling by switching to zend_string can cause mismatched types and unsafe memory access.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing data handling by switching to zend_string can cause mismatched types and unsafe memory access.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-617] → [CWE-190] Integer Overflow or Wraparound</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 2</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing reachable assertion by adding bounds checks can leave other integer overflow conditions unchecked.</span>
              <span class="pattern-count">(2 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing integer overflow by checking specific bounds can cause other overflow conditions to go unchecked.</li><li>Fixing UVLC error detection by post-multiplying delta can cause integer overflow in index checks.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-617] → [CWE-401] Missing Release of Memory after Effective Lifetime</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 2</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing reachable assertion by throwing exceptions or adding error exits can cause memory leaks when cleanup code is bypassed in error paths.</span>
              <span class="pattern-count">(2 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing NULL checks for allocation failures by only handling one variable can cause memory leaks.</li><li>Fixing NULL image dereference by reordered cleanup can cause memory leaks in alternate error paths.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-617] → [CWE-787] Out-of-bounds Write</h2>
          <div class="meta">
            <span class="stats">Patterns: 2 • Records: 2</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing unreachable assertion by NULL checks can cause buffer overflow due to missing boundary validations.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing unreachable assertion by NULL checks can cause buffer overflow due to missing boundary validations.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P2</span>
              <span class="pattern-title">Fixing rank validation by element checks can cause memory corruption with incorrect tensor dimensions.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing rank validation by element checks can cause memory corruption with incorrect tensor dimensions.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-703] → [CWE-119] Improper Restriction of Operations within the Bounds of a Memory Buffer</h2>
          <div class="meta">
            <span class="stats">Patterns: 2 • Records: 2</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing out-of-bounds read by operand swapping can cause incorrect position calculation and potential overflow.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing out-of-bounds read by operand swapping can cause incorrect position calculation and potential overflow.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P2</span>
              <span class="pattern-title">Fixing duration mismatch by unconditional time setting can cause buffer overflows in voice processing.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing duration mismatch by unconditional time setting can cause buffer overflows in voice processing.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-703] → [CWE-190] Integer Overflow or Wraparound</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 2</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing error checking by adding bounds validation can introduce integer overflow in calculations.</span>
              <span class="pattern-count">(2 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing buffer overflow by bounds checking can cause integer overflow through signed/unsigned subtraction.</li><li>Fixing double-fdput by altering refcount handling can cause integer overflow vulnerabilities on large systems.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-703] → [CWE-362] Concurrent Execution using Shared Resource with Improper Synchronization (&#x27;Race Condition&#x27;)</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 2</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing error handling by modifying cleanup can introduce race conditions.</span>
              <span class="pattern-count">(2 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing error cleanup by adding work queue handling can cause race conditions on disconnect.</li><li>Fixing unmounted mount checks by optimistic validation can cause race conditions with improper synchronization.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-703] → [CWE-416] Use After Free</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 2</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing error checking by modifying resource handling can introduce use-after-free vulnerabilities.</span>
              <span class="pattern-count">(2 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing endpoint counting by using static altsetting can cause erroneous resource usage checks or binding.</li><li>Fixing netdevice leaks by conditional releases can cause premature release of valid references.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-703] → [CWE-772] Missing Release of Resource after Effective Lifetime</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 2</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing error handling by adding cleanup can miss related allocations causing resource leaks.</span>
              <span class="pattern-count">(2 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing memory cleanup by releasing one allocation can cause neglect in releasing related allocations.</li><li>Fixing invalid memory access by early device unlocks can cause resource leakage due to missed deallocation.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-77] → [CWE-20] Improper Input Validation</h2>
          <div class="meta">
            <span class="stats">Patterns: 2 • Records: 2</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing command-line validation by increment logic can cause argument handling errors.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing command-line validation by increment logic can cause argument handling errors.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P2</span>
              <span class="pattern-title">Fixing argument increment logic by simplifying can cause improper handling of option arguments.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing argument increment logic by simplifying can cause improper handling of option arguments.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-770] → [CWE-190] Integer Overflow or Wraparound</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 2</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing resource allocation limits can introduce integer overflow in size calculations.</span>
              <span class="pattern-count">(2 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing buffer overflow by incorrect size checks can cause integer overflow due to miscalculation of packet size.</li><li>Fixing resource management omission by commenting validation can cause unchecked entry_count to overflow.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-772] → [CWE-401] Improper Release of Memory Before Removing Last Reference</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 2</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing resource leaks with partial cleanup can cause memory leaks when other allocated resources remain unreleased.</span>
              <span class="pattern-count">(2 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing memory leaks by adding individual cleanups can cause incomplete resource deallocation under multiple errors.</li><li>Fixing unsupported data type errors with partial cleanup can cause memory leaks via unreleased pointers.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-772] → [CWE-416] Use After Free</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 2</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing resource leaks by adding cleanup can introduce use-after-free when timing is incorrect.</span>
              <span class="pattern-count">(2 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing memory leak by async deletions can cause use after free when deletion overlaps namespace destruction.</li><li>Fixing resource cleanup via premature free can cause use-after-free errors in alternative code paths.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-772] → [CWE-476] NULL Pointer Dereference</h2>
          <div class="meta">
            <span class="stats">Patterns: 2 • Records: 2</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing reference counting by suppressing decrements can cause memory leaks in specific configurations.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing reference counting by suppressing decrements can cause memory leaks in specific configurations.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P2</span>
              <span class="pattern-title">Fixing resource cleanup by adding delete calls can cause NULL pointer dereference without initial checks.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing resource cleanup by adding delete calls can cause NULL pointer dereference without initial checks.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-787] → [CWE-170] Improper Null Termination</h2>
          <div class="meta">
            <span class="stats">Patterns: 2 • Records: 2</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing buffer overflow with improper null termination can cause string truncation issues.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing buffer overflow with improper null termination can cause string truncation issues.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P2</span>
              <span class="pattern-title">Fixing large string processing by limiting node sizes can cause failure to handle large but valid text entries.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing large string processing by limiting node sizes can cause failure to handle large but valid text entries.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-787] → [CWE-252] Unchecked Return Value</h2>
          <div class="meta">
            <span class="stats">Patterns: 2 • Records: 2</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing buffer size validation by adding checks can cause unchecked return paths leading to improper fallthrough.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing buffer size validation by adding checks can cause unchecked return paths leading to improper fallthrough.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P2</span>
              <span class="pattern-title">Fixing buffer overflow by limiting precision can cause failure handling issues due to unchecked return values.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing buffer overflow by limiting precision can cause failure handling issues due to unchecked return values.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-787] → [CWE-693] Protection Mechanism Failure</h2>
          <div class="meta">
            <span class="stats">Patterns: 2 • Records: 2</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing out-of-bounds reads with inconsistent boundary checks can cause incomplete protection mechanisms.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing out-of-bounds reads with inconsistent boundary checks can cause incomplete protection mechanisms.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P2</span>
              <span class="pattern-title">Fixing TLB flush logic with additional conditions can cause protection mechanism failure by missing essential flushes.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing TLB flush logic with additional conditions can cause protection mechanism failure by missing essential flushes.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-835] → [CWE-126] Buffer Over-read</h2>
          <div class="meta">
            <span class="stats">Patterns: 2 • Records: 2</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing invalid LZW code acceptance by improper length return can cause buffer overreads.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing invalid LZW code acceptance by improper length return can cause buffer overreads.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P2</span>
              <span class="pattern-title">Fixing loop termination by setting buffer to empty can cause unintended buffer over-read.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing loop termination by setting buffer to empty can cause unintended buffer over-read.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-835] → [CWE-190] Integer Overflow or Wraparound</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 2</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing infinite loops by adding early exits can miss integer overflow checks.</span>
              <span class="pattern-count">(2 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing zero sample rate by early returns can cause missed overflow checks leading to buffer overruns.</li><li>Fixing sign issue by type casting can cause overflow when shifting to maximum bit positions.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-835] → [CWE-416] Use After Free</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 2</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing infinite loops by modifying loop control can introduce use-after-free errors.</span>
              <span class="pattern-count">(2 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing EOF without cleanup can cause use-after-free when error conditions are not properly handled.</li><li>Fixing pointer advancement in loops can cause use-after-free errors if not handled correctly.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-88] → [CWE-22] Improper Limitation of a Pathname to a Restricted Directory (&#x27;Path Traversal&#x27;)</h2>
          <div class="meta">
            <span class="stats">Patterns: 2 • Records: 2</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing submodule option parsing by adding -- can cause directory traversal due to improper name handling.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing submodule option parsing by adding -- can cause directory traversal due to improper name handling.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P2</span>
              <span class="pattern-title">Fixing command-line injection in URLs by banning leading-dash URLs can cause similar vulnerabilities in paths.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing command-line injection in URLs by banning leading-dash URLs can cause similar vulnerabilities in paths.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-908] → [CWE-119] Improper Restriction of Operations within the Bounds of a Memory Buffer</h2>
          <div class="meta">
            <span class="stats">Patterns: 2 • Records: 2</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing stream shutdown conditions by introducing &#x27;in_generator&#x27; can cause undefined behavior with zero-offset pointer dereference.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing stream shutdown conditions by introducing &#x27;in_generator&#x27; can cause undefined behavior with zero-offset pointer dereference.</li>
              </ul>
            </details>
          </div>
        
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P2</span>
              <span class="pattern-title">Fixing uninitialized read by setting default values can cause overflow due to improper Unicode handling.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing uninitialized read by setting default values can cause overflow due to improper Unicode handling.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-1021] → [CWE-200] Exposure of Sensitive Information to an Unauthorized Actor</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing visibility check by not considering unload state can cause information exposure during navigation.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing visibility check by not considering unload state can cause information exposure during navigation.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-119] → [CWE-121] Stack-based Buffer Overflow</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing file descriptor handling by platform-independent casting can cause stack buffer overflow on 64-bit Windows systems.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing file descriptor handling by platform-independent casting can cause stack buffer overflow on 64-bit Windows systems.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-119] → [CWE-122] Heap-based Buffer Overflow</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing heap overflow by enlarging buffer size can cause residual overflow due to insufficient buffer increase.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing heap overflow by enlarging buffer size can cause residual overflow due to insufficient buffer increase.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-119] → [CWE-124] Buffer Underwrite (&#x27;Buffer Underflow&#x27;)</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing invalid color indices in one function can cause unchecked negative indices elsewhere.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing invalid color indices in one function can cause unchecked negative indices elsewhere.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-119] → [CWE-127] Buffer Under-read</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing register truncation by coerce_reg_to_size can cause speculative buffer under-read vulnerabilities.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing register truncation by coerce_reg_to_size can cause speculative buffer under-read vulnerabilities.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-119] → [CWE-1284] Improper Validation of Specified Quantity in Input</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing size bounds checks by basic validation can cause insufficient command-specific size validation.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing size bounds checks by basic validation can cause insufficient command-specific size validation.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-119] → [CWE-130] Improper Handling of Length Parameter Inconsistency</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing rootseek checks by duplicate condition can cause missed negative size checks leading to integer overflow.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing rootseek checks by duplicate condition can cause missed negative size checks leading to integer overflow.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-119] → [CWE-131] Improper Calculation of Buffer Size</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing buffer overflow with size calculations/allocations but insufficient accounting for padding/varying sizes causes inadequate memory allocation.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing image handling by thread count allocation can cause insufficient memory for image list.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-119] → [CWE-134] Use of Externally-Controlled Format String</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing packet size handling by adding format checks can cause format string vulnerabilities.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing packet size handling by adding format checks can cause format string vulnerabilities.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-119] → [CWE-173] Improper Handling of Alternate Encoding</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing encoding conversion failures by stopping the parser can cause improper alternate encoding handling.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing encoding conversion failures by stopping the parser can cause improper alternate encoding handling.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-119] → [CWE-195] Signed to Unsigned Conversion Error</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing BPF verifier bounds by using unsigned variables can cause incorrect error handling.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing BPF verifier bounds by using unsigned variables can cause incorrect error handling.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-119] → [CWE-284] Improper Access Control</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing user pointer validation by restricting read/write can cause improper stack access validation.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing user pointer validation by restricting read/write can cause improper stack access validation.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-119] → [CWE-327] Use of a Broken or Risky Cryptographic Algorithm</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing openssl memory corruption by removing MD5 can cause algorithm fallback to insecure MD5.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing openssl memory corruption by removing MD5 can cause algorithm fallback to insecure MD5.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-119] → [CWE-361] Time-of-check Time-of-use (TOCTOU) Race Condition</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing overflow with length checks by using strnlen can cause TOCTOU race condition with duplicate filename handling.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing overflow with length checks by using strnlen can cause TOCTOU race condition with duplicate filename handling.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-119] → [CWE-369] Divide By Zero</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing buffer overflow with type casting can cause division-by-zero in geometric calculations.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing buffer overflow with type casting can cause division-by-zero in geometric calculations.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-119] → [CWE-399] Resource Management Errors</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing UDP UFO handling by conditional skb initialization can cause incomplete packet setups leading to memory corruption.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing UDP UFO handling by conditional skb initialization can cause incomplete packet setups leading to memory corruption.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-119] → [CWE-400] Uncontrolled Resource Consumption</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing buffer overflow by heap size adjustments can cause termination on allocation failures.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing buffer overflow by heap size adjustments can cause termination on allocation failures.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-119] → [CWE-404] Improper Resource Shutdown or Release</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing image resource management by replacing destroy calls with free can cause improper resource deallocation.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing image resource management by replacing destroy calls with free can cause improper resource deallocation.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-119] → [CWE-411] Improper Handling of Unused Values</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing buffer overflow by using overflow flag can cause improper handling of zero-length packets.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing buffer overflow by using overflow flag can cause improper handling of zero-length packets.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-119] → [CWE-457] Use of Uninitialized Variable</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing null pointer dereference by using arbitrary address bounds can cause uninitialized variable usage.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing null pointer dereference by using arbitrary address bounds can cause uninitialized variable usage.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-119] → [CWE-502] Deserialization of Untrusted Data</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing unserialize handling by not validating data properly can cause memory safety vulnerabilities.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing unserialize handling by not validating data properly can cause memory safety vulnerabilities.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-119] → [CWE-640] Weak Password Recovery Mechanism for Forgotten Password</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing bounds check by adjusting offset update can cause incorrect file stream positioning errors.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing bounds check by adjusting offset update can cause incorrect file stream positioning errors.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-119] → [CWE-661] Improper Passing of Data Structure</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing buffer length handling by using requested lengths can cause data overreads due to incorrect buffer size updates.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing buffer length handling by using requested lengths can cause data overreads due to incorrect buffer size updates.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-119] → [CWE-667] Improper Locking</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing DMA by using shared buffer can cause incorrect handling of read/write flags.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing DMA by using shared buffer can cause incorrect handling of read/write flags.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-119] → [CWE-671] Insufficient Logging</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing packet length checks by adjusting bodylen can cause partially processed packets without proper error reporting.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing packet length checks by adjusting bodylen can cause partially processed packets without proper error reporting.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-119] → [CWE-674] Uncontrolled Recursion</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing stack overflow by shallow recursion limits can cause deep recursion vulnerabilities in related functions.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing stack overflow by shallow recursion limits can cause deep recursion vulnerabilities in related functions.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-119] → [CWE-682] Incorrect Calculation</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing pixel buffer overruns by npix checks can cause incorrect pixel count calculations.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing pixel buffer overruns by npix checks can cause incorrect pixel count calculations.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-119] → [CWE-685] Incorrect Assignment</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing stack overflow by bounds checking can cause incorrect memory management via flawed loop conditions.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing stack overflow by bounds checking can cause incorrect memory management via flawed loop conditions.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-119] → [CWE-705] Functionality Misuse</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing buffer overflow by adding length checks can cause issues in specific OS handling of functions.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing buffer overflow by adding length checks can cause issues in specific OS handling of functions.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-119] → [CWE-732] Incorrect Permission Assignment for Critical Resource</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing futex key ref-counting by altering logic can cause improper permission assignment issues.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing futex key ref-counting by altering logic can cause improper permission assignment issues.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-119] → [CWE-77] Improper Neutralization of Special Elements used in a Command (&#x27;Command Injection&#x27;)</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing negative integer checks by updating int handling can cause command injection through unchecked conversion.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing negative integer checks by updating int handling can cause command injection through unchecked conversion.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-119] → [CWE-770] Allocation of Resources Without Limits or Throttling</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing invalid write by removing size limit can cause resource allocation vulnerabilities.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing invalid write by removing size limit can cause resource allocation vulnerabilities.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-119] → [CWE-775] Missing Release of Resource after Effective Lifetime</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing ZIP handling by adjusting error pathways can cause memory leaks if resources aren&#x27;t released.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing ZIP handling by adjusting error pathways can cause memory leaks if resources aren&#x27;t released.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-119] → [CWE-819] Inconsistent Interpretation of Logical Expressions</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing async binding in arrow functions can cause block-scoped function visibility bugs in with statements.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing async binding in arrow functions can cause block-scoped function visibility bugs in with statements.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-119] → [CWE-833] Deadlock</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing buffer length checks by retaining session locks can cause ABBA deadlock scenarios.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing buffer length checks by retaining session locks can cause ABBA deadlock scenarios.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-119] → [CWE-840] Game Input Data Failure</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing X509 name handling by concatenating different SANs types can cause improper rule matching for UPN SANs.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing X509 name handling by concatenating different SANs types can cause improper rule matching for UPN SANs.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-119] → [CWE-843] Type Confusion</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing use-after-free by altering object handling can cause type confusion vulnerabilities.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing use-after-free by altering object handling can cause type confusion vulnerabilities.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-119] → [CWE-843] Access of Resource Using Incompatible Type (&#x27;Type Confusion&#x27;)</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P2</span>
              <span class="pattern-title">Fixing PS handling by resetting allocation for one channel can cause misallocation in multi-channel scenarios.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing PS handling by resetting allocation for one channel can cause misallocation in multi-channel scenarios.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-119] → [CWE-93] Improper Neutralization of CRLF Sequences in HTTP Headers (&#x27;HTTP Response Splitting&#x27;)</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing buffer over-read by checking first header occurrence can cause header injection via unverified duplicates.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing buffer over-read by checking first header occurrence can cause header injection via unverified duplicates.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-120] → [CWE-119] Improper Restriction of Operations within the Bounds of a Memory Buffer</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing buffer overflow by simple allocation can cause improper buffer restriction and new overflows.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing buffer overflow by simple allocation can cause improper buffer restriction and new overflows.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-120] → [CWE-131] Incorrect Calculation of Buffer Size</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing buffer overflow by naive size checks can cause calculation errors leading to under-allocated memory.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing buffer overflow by naive size checks can cause calculation errors leading to under-allocated memory.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-120] → [CWE-369] Divide By Zero</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing out-of-bounds by input checks can cause division by zero during parameter calculations.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing out-of-bounds by input checks can cause division by zero during parameter calculations.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-120] → [CWE-401] Improper Release of Memory Before Removing Last Reference (&#x27;Memory Leak&#x27;)</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing fragment overflow by limiting fragments can cause memory leaks without proper release.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing fragment overflow by limiting fragments can cause memory leaks without proper release.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-120] → [CWE-703] Improper Check or Handling of Exceptional Conditions</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing exp-golomb parsing by adding input validation can cause improper error handling in HRD parsing.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing exp-golomb parsing by adding input validation can cause improper error handling in HRD parsing.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-120] → [CWE-787] Out-of-bounds Write</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing rep_format_idx validation by error logging can cause layer ID index overflow.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing rep_format_idx validation by error logging can cause layer ID index overflow.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-120] → [CWE-834] Excessive Iteration</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing buffer overflow by moving a bounds check can cause an unintended loop misbehavior.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing buffer overflow by moving a bounds check can cause an unintended loop misbehavior.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-120] → [CWE-94] Improper Control of Generation of Code (&#x27;Code Injection&#x27;)</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing memory overwrite by sanitizing inputs can cause exposure to injection vulnerabilities through script evaluation.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing memory overwrite by sanitizing inputs can cause exposure to injection vulnerabilities through script evaluation.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-121] → [CWE-682] Incorrect Calculation</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing entity recursion by adding assert can cause calculation errors in release builds.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing entity recursion by adding assert can cause calculation errors in release builds.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-122] → [CWE-401] Improper Release of Memory Before Removing Last Reference (&#x27;Memory Leak&#x27;)</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing buffer overflow by early returns can cause memory leaks if allocated resources are not freed.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing buffer overflow by early returns can cause memory leaks if allocated resources are not freed.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-125] → [CWE-111] Improper Handling of Undefined (Null) Values</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing buffer overflow by parameter validation can cause platform-specific logic errors across environments.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing buffer overflow by parameter validation can cause platform-specific logic errors across environments.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-125] → [CWE-121] Stack-based Buffer Overflow</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing parsing loop by checking against input length can cause overflow when buffer size is smaller.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing parsing loop by checking against input length can cause overflow when buffer size is smaller.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-125] → [CWE-124] Buffer Underwrite (&#x27;Buffer Underflow&#x27;)</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing out-of-bounds writes by adding bounds checks can cause buffer underflow due to incomplete checks.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing out-of-bounds writes by adding bounds checks can cause buffer underflow due to incomplete checks.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-125] → [CWE-126] Buffer Over-read</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing out-of-bounds by header-only length checks can cause buffer over-read for larger-specific descriptors.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing out-of-bounds by header-only length checks can cause buffer over-read for larger-specific descriptors.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-125] → [CWE-166] Improper Handling of Insufficient Privileges/Permissions</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing string expansion optimization by narrowing checks can cause incorrect case-insensitive match failures.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing string expansion optimization by narrowing checks can cause incorrect case-insensitive match failures.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-125] → [CWE-191] Integer Underflow (Wrap or Wraparound)</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing integer overflow by checking bounds can cause integer underflow when subtracting without proper checks.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing integer overflow by checking bounds can cause integer underflow when subtracting without proper checks.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-125] → [CWE-193] Off-by-one Error</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing out-of-bounds by adjusting index bounds can cause off-by-one errors in conditional checks.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing out-of-bounds by adjusting index bounds can cause off-by-one errors in conditional checks.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-125] → [CWE-195] Signed to Unsigned Conversion Error</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing heap overflow by adjusting buffer checks can cause signed to unsigned conversion errors.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing heap overflow by adjusting buffer checks can cause signed to unsigned conversion errors.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-125] → [CWE-362] Race Condition</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing buffer over-read by reordering operations can introduce race conditions in concurrent access scenarios.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing initial chunk length check ordering can cause unsafe data accesses during concurrent packet abort operations.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-125] → [CWE-362] Concurrent Execution using Shared Resource with Improper Synchronization (&#x27;Race Condition&#x27;)</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing buffer over-read by reordering operations can introduce race conditions in concurrent access scenarios.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing stack readjustment by moving context switch can cause race conditions in fiber operations.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-125] → [CWE-400] Uncontrolled Resource Consumption (&#x27;Resource Exhaustion&#x27;)</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing pixel channel logic by inefficient cache handling can cause resource exhaustion.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing pixel channel logic by inefficient cache handling can cause resource exhaustion.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-125] → [CWE-401] Missing Release of Memory after Effective Lifetime</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing buffer over-read by modifying control flow or adding early exits can cause memory leaks when cleanup code is bypassed in error paths.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing buffer overflow by early exit without freeing memory can cause memory leaks.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-125] → [CWE-404] Improper Resource Shutdown or Release</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing heap buffer overflow by error checks can cause improper resource cleanup.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing heap buffer overflow by error checks can cause improper resource cleanup.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-125] → [CWE-611] Improper Restriction of XML External Entity Reference</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing heap overread by null-termination checks can cause legitimate PSP files to be improperly rejected.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing heap overread by null-termination checks can cause legitimate PSP files to be improperly rejected.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-125] → [CWE-681] Incorrect Conversion between Numeric Types</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing buffer indexing by multiplying offsets with GetPixelChannels can cause logical errors in handling remainder calculations.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing buffer indexing by multiplying offsets with GetPixelChannels can cause logical errors in handling remainder calculations.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-125] → [CWE-682] Incorrect Calculation</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing 32-bit ALU ops by truncating outputs can cause input mismatch errors on right shifts.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing 32-bit ALU ops by truncating outputs can cause input mismatch errors on right shifts.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-125] → [CWE-683] Function Call With Incorrect Argument Type</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing out-of-bounds access by pointer casting can cause unaligned memory dereference issues in strict alignment architectures.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing out-of-bounds access by pointer casting can cause unaligned memory dereference issues in strict alignment architectures.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-125] → [CWE-685] Function Call With Incorrect Argument Number or Type</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing out-of-bounds read by correcting pointer usage can cause incorrect calculations for stream seeks.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing out-of-bounds read by correcting pointer usage can cause incorrect calculations for stream seeks.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-125] → [CWE-693] Protection Mechanism Failure</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing buffer over-read in DHCPv6 by bounds checks can cause similar bugs unchecked in DHCPv4.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing buffer over-read in DHCPv6 by bounds checks can cause similar bugs unchecked in DHCPv4.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-125] → [CWE-704] Incorrect Type Conversion or Cast</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing out-of-bounds read by switching from array to function can cause unmasked flag-related errors in switch cases.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing out-of-bounds read by switching from array to function can cause unmasked flag-related errors in switch cases.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-125] → [CWE-733] Improper Handling of Insufficient Permissions or Privileges</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing success determination by only checking exceptions can cause improper handling of write operation failures.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing success determination by only checking exceptions can cause improper handling of write operation failures.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-125] → [CWE-772] Missing Release of Resource after Effective Lifetime</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing width-only zero check can cause resource handling issues by bypassing height-zero concern.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing width-only zero check can cause resource handling issues by bypassing height-zero concern.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-125] → [CWE-775] Missing Release of Resource after Effective Lifetime</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing unchecked output handling by simple conditional checks can cause resource leakage under error conditions.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing unchecked output handling by simple conditional checks can cause resource leakage under error conditions.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-125] → [CWE-824] Access of Uninitialized Pointer</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing buffer over-read by adjusting checks can cause invalid buffer-access due to incorrect pointer use.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing buffer over-read by adjusting checks can cause invalid buffer-access due to incorrect pointer use.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-125] → [CWE-834] Excessive Iteration</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing capability length check by missing pointer advancement can cause infinite loops on malformed inputs.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing capability length check by missing pointer advancement can cause infinite loops on malformed inputs.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-125] → [CWE-835] Loop with Unreachable Exit Condition (&#x27;Infinite Loop&#x27;)</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing pixel setting by using hardcoded values can cause incorrect data handling and memory issues.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing pixel setting by using hardcoded values can cause incorrect data handling and memory issues.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-125] → [CWE-841] Improper Neutralization of Out-of-Bounds Data Read</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing flow control PDU reading by skipping actual channel_id can cause incorrect channel operations.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing flow control PDU reading by skipping actual channel_id can cause incorrect channel operations.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-125] → [CWE-841] Improper Restriction of Excessive Authentication Attempts</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P2</span>
              <span class="pattern-title">Fixing parsing by calling base read function can cause unchecked box structure access.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing parsing by calling base read function can cause unchecked box structure access.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-1284] → [CWE-354] Improper Validation of Integrity Check Value</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing GTP-U packet size by strict validations can cause improper filtering of legitimate packets.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing GTP-U packet size by strict validations can cause improper filtering of legitimate packets.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-129] → [CWE-120] Buffer Copy without Checking Size of Input (&#x27;Classic Buffer Overflow&#x27;)</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing segno and blkoff validation by ignoring bitmap size checks can cause buffer overflow.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing segno and blkoff validation by ignoring bitmap size checks can cause buffer overflow.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-129] → [CWE-190] Integer Overflow or Wraparound</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing uvlc code reading by allowing overlong codes can cause integer overflow by missing upper bounds check.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing uvlc code reading by allowing overlong codes can cause integer overflow by missing upper bounds check.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-131] → [CWE-125] Out-of-bounds Read</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing assertion handling by OP_REQUIRES can cause unchecked array access leading to out-of-bounds read.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing assertion handling by OP_REQUIRES can cause unchecked array access leading to out-of-bounds read.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-16] → [CWE-770] Allocation of Resources Without Limits or Throttling</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing transaction overwrite by strict checks can cause unbounded resource consumption during reorganization.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing transaction overwrite by strict checks can cause unbounded resource consumption during reorganization.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-17] → [CWE-266] Incorrect Privilege Assignment</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing privilege level checks by focusing only on privilege levels can cause improper validation of branch target addresses.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing privilege level checks by focusing only on privilege levels can cause improper validation of branch target addresses.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-17] → [CWE-276] Incorrect Default Permissions</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing container escape by procfd restriction can cause incorrect permissions leading to namespace access.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing container escape by procfd restriction can cause incorrect permissions leading to namespace access.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-17] → [CWE-388] Improper Error Handling</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing data copying by switching to new iterators can cause silent failure due to unhandled error conditions.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing data copying by switching to new iterators can cause silent failure due to unhandled error conditions.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-17] → [CWE-401] Missing Release of Memory after Effective Lifetime</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing jump passes by extra iterations can cause memory leaks when JIT compilation doesn&#x27;t converge.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing jump passes by extra iterations can cause memory leaks when JIT compilation doesn&#x27;t converge.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-17] → [CWE-415] Double Free</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing invalid free by adjusting memory management can cause double free when conditions are improperly checked.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing invalid free by adjusting memory management can cause double free when conditions are improperly checked.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-17] → [CWE-640] Weakness in Documention Algorithm</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing script element&#x27;s document movement by context document checks can cause improper script disassociation.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing script element&#x27;s document movement by context document checks can cause improper script disassociation.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-17] → [CWE-691] Insufficient Control Flow Management</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing block allocation by removing extent info can cause loss of delalloc extent tracking.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing block allocation by removing extent info can cause loss of delalloc extent tracking.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-17] → [CWE-703] Improper Check or Handling of Exceptional Conditions</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing ASSERTs by graceful returns can cause unchecked conditions leading to crashes when resources are constrained.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing ASSERTs by graceful returns can cause unchecked conditions leading to crashes when resources are constrained.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-17] → [CWE-787] Out-of-bounds Write</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing window offset validation by tracking &#x27;initialized&#x27; can cause unchecked buffer growth and overflow during data copy.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing window offset validation by tracking &#x27;initialized&#x27; can cause unchecked buffer growth and overflow during data copy.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-184] → [CWE-665] Improper Initialization</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing incomplete operand checks by partial type validation can cause device state inconsistency.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing incomplete operand checks by partial type validation can cause device state inconsistency.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-189] → [CWE-119] Improper Restriction of Operations within the Bounds of a Memory Buffer</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing user memory access by using import_iovec() can cause compatibility-mode memory buffer mismatches.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing user memory access by using import_iovec() can cause compatibility-mode memory buffer mismatches.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-189] → [CWE-120] Buffer Copy without Checking Size of Input (&#x27;Classic Buffer Overflow&#x27;)</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing buffer copy length by res.acl_len change can cause buffer overflows if not properly handled.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing buffer copy length by res.acl_len change can cause buffer overflows if not properly handled.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-189] → [CWE-126] Buffer Over-read</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing integer overflow using safe functions can cause incorrect buffer scanning methods causing overreads.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing integer overflow using safe functions can cause incorrect buffer scanning methods causing overreads.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-189] → [CWE-131] Incorrect Calculation of Buffer Size</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing array out-of-bounds by changing alignment order can cause buffer overflows with misaligned tile dimensions.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing array out-of-bounds by changing alignment order can cause buffer overflows with misaligned tile dimensions.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-189] → [CWE-191] Integer Underflow (Wrap or Wraparound)</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing segmentation fault by adding value length checks can cause underflow in expiration time handling.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing segmentation fault by adding value length checks can cause underflow in expiration time handling.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-189] → [CWE-193] Off-by-one Error</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing buffer overflow by limiting index can cause an off-by-one overflow due to incorrect boundary checks.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing buffer overflow by limiting index can cause an off-by-one overflow due to incorrect boundary checks.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-189] → [CWE-197] Numeric Truncation Error</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing overflow checks by using larger unsigned types can cause signed iteration overflow.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing overflow checks by using larger unsigned types can cause signed iteration overflow.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-189] → [CWE-363] Race Condition</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing deadlock by changing spinlock timing can cause race condition and NULL dereferences.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing deadlock by changing spinlock timing can cause race condition and NULL dereferences.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-189] → [CWE-369] Divide By Zero</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing FPE by missing zero components check can cause division by zero in rational calculations.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing FPE by missing zero components check can cause division by zero in rational calculations.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-189] → [CWE-401] Improper Release of Memory Before Removing Last Reference (&#x27;Memory Leak&#x27;)</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing unpinned pages by adjusting parameters can cause excessive unpinning, leading to memory leaks.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing unpinned pages by adjusting parameters can cause excessive unpinning, leading to memory leaks.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-189] → [CWE-494] Deserialization of Untrusted Data</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing overflow by delaying GTT bind can cause incorrect memory writes through unchecked buffer reuse.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing overflow by delaying GTT bind can cause incorrect memory writes through unchecked buffer reuse.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-189] → [CWE-563] Assignment of a Fixed Address to a Pointer</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing uninitialized pointer handling by incorrect memory assignments can cause memory safety issues.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing uninitialized pointer handling by incorrect memory assignments can cause memory safety issues.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-189] → [CWE-616] Incomplete Comparison and Logic Operations</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing boundary-check by &#x27;&gt;=&#x27; comparator can cause unintended boundary logic inconsistencies.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing boundary-check by &#x27;&gt;=&#x27; comparator can cause unintended boundary logic inconsistencies.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-189] → [CWE-674] Uncontrolled Recursion</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing endless loops by breaking on zero can cause deep recursion issues due to lack of tag restrictions.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing endless loops by breaking on zero can cause deep recursion issues due to lack of tag restrictions.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-189] → [CWE-681] Incorrect Conversion between Numeric Types</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing integer overflow by rounding size can cause truncation issues on 64-bit platforms.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing integer overflow by rounding size can cause truncation issues on 64-bit platforms.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-189] → [CWE-703] Improper Check or Handling of Exceptional Conditions</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing size-multiplication overflow by early NULL returns can cause inconsistent failure handling across callers.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing size-multiplication overflow by early NULL returns can cause inconsistent failure handling across callers.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-189] → [CWE-770] Allocation of Resources Without Limits or Throttling</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing integer overflow by lower bound check can cause excessive memory allocation vulnerability.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing integer overflow by lower bound check can cause excessive memory allocation vulnerability.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-189] → [CWE-843] Access of Resource Using Incompatible Type (&#x27;Type Confusion&#x27;)</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing type safety by adding checks can cause type confusion in variable assignments.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing type safety by adding checks can cause type confusion in variable assignments.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-19] → [CWE-121] Stack-based Buffer Overflow</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing integer formatting by updating format strings can cause buffer overflow if buffers are inadequately sized.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing integer formatting by updating format strings can cause buffer overflow if buffers are inadequately sized.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-19] → [CWE-362] Race Condition</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing use-after-free by managing sk_err changes can cause concurrent access race conditions.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing use-after-free by managing sk_err changes can cause concurrent access race conditions.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-19] → [CWE-416] Use After Free</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing chain deletion order can cause dangling references and potential use-after-free vulnerabilities.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing chain deletion order can cause dangling references and potential use-after-free vulnerabilities.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-19] → [CWE-787] Out-of-bounds Write</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing uninitialized memory by zero-initialization can cause buffer overflow from improper bounds checking.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing uninitialized memory by zero-initialization can cause buffer overflow from improper bounds checking.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-190] → [CWE-117] Improper Output Neutralization for Logs</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing CSV parsing inconsistency by omitting escape character handling can cause CSV injection vulnerabilities.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing CSV parsing inconsistency by omitting escape character handling can cause CSV injection vulnerabilities.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-190] → [CWE-118] Improper Access of Indexable Resource (&#x27;Indexing Error&#x27;)</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing int/size_t type confusion improperly handled CSV parser state, causing incorrect field splits.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing int/size_t type confusion improperly handled CSV parser state, causing incorrect field splits.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-190] → [CWE-119] Improper Restriction of Operations within the Bounds of a Memory Buffer</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Changing keylen from uint16_t to int can allow buffer overflows due to weakened bounds checking.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Changing keylen from uint16_t to int can allow buffer overflows due to weakened bounds checking.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-190] → [CWE-121] Stack-based Buffer Overflow</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing integer overflow by arithmetic adjustments can cause incorrect size validation for structural data.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing integer overflow by arithmetic adjustments can cause incorrect size validation for structural data.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-190] → [CWE-124] Buffer Underwrite (&#x27;Buffer Underflow&#x27;)</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing integer overflow by updating struct package can cause underflow with incorrect offset handling.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing integer overflow by updating struct package can cause underflow with incorrect offset handling.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-190] → [CWE-131] Incorrect Calculation of Buffer Size</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing integer overflow by redefining buffer type can cause incorrect buffer calculations due to oversight of multiplicative operations.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing integer overflow by redefining buffer type can cause incorrect buffer calculations due to oversight of multiplicative operations.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-190] → [CWE-193] Off-by-one Error</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing integer overflow by upper-bound checks can cause off-by-one errors by missing zero state validation.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing integer overflow by upper-bound checks can cause off-by-one errors by missing zero state validation.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-190] → [CWE-197] Numeric Truncation Error</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing integer overflow by using size_t can cause numeric truncation when downcasting to int.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing integer overflow by using size_t can cause numeric truncation when downcasting to int.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-190] → [CWE-338] Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing integer overflow risk by altering random data checks can cause weak IV generation due to incomplete random reads.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing integer overflow risk by altering random data checks can cause weak IV generation due to incomplete random reads.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-190] → [CWE-362] Concurrent Execution using Shared Resource with Improper Synchronization (&#x27;Race Condition&#x27;)</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing integer overflow by adjusting range checks can cause race conditions due to shared resource reuse.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing integer overflow by adjusting range checks can cause race conditions due to shared resource reuse.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-190] → [CWE-367] Time-of-check Time-of-use (TOCTOU) Race Condition</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing input validation by using proc_dointvec_minmax can cause validation bypass due to improper check placement.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing input validation by using proc_dointvec_minmax can cause validation bypass due to improper check placement.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-190] → [CWE-404] Improper Resource Shutdown or Release</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing segmentation fault by adding socket state checks can cause socket leak on shutdown due to improper resource handling.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing segmentation fault by adding socket state checks can cause socket leak on shutdown due to improper resource handling.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-190] → [CWE-415] Double Free</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing cast-related overflow by unchecked thumbnail operations can cause resources to be improperly released.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing cast-related overflow by unchecked thumbnail operations can cause resources to be improperly released.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-190] → [CWE-416] Use After Free</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing integer overflow by altering cleanup logic can cause use-after-free due to incorrect loop conditions.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing integer overflow by altering cleanup logic can cause use-after-free due to incorrect loop conditions.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-190] → [CWE-476] NULL Pointer Dereference</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing buffer overflows by length checks can cause NULL pointer dereferences upon failed data validity.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing buffer overflows by length checks can cause NULL pointer dereferences upon failed data validity.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-190] → [CWE-480] Use of Incorrect Operator</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing overflow by limiting dimensions with bitwise OR can cause logical errors in conditional checks.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing overflow by limiting dimensions with bitwise OR can cause logical errors in conditional checks.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-190] → [CWE-617] Reachable Assertion</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing addition overflow by asserting conditions can cause production failures when assertions are disabled.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing addition overflow by asserting conditions can cause production failures when assertions are disabled.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-190] → [CWE-670] Always-Incorrect Control Flow Implementation</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing partial match checks by incorrect logic can cause valid matches to be overlooked.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing partial match checks by incorrect logic can cause valid matches to be overlooked.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-190] → [CWE-672] Operation on a Resource after Expiration or Release</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing table size safeguards by altering iterator logic can cause iteration inconsistencies if arrays change during loops.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing table size safeguards by altering iterator logic can cause iteration inconsistencies if arrays change during loops.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-190] → [CWE-674] Uncontrolled Recursion</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing integer overflow by changing recursion can cause stack exhaustion vulnerability.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing integer overflow by changing recursion can cause stack exhaustion vulnerability.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-190] → [CWE-685] Function Call With Incorrect Number of Arguments</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing negative ID checks using unsigned types can cause ineffective security checks.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing negative ID checks using unsigned types can cause ineffective security checks.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-190] → [CWE-691] Insufficient Control Flow Management</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing overflow in one function by bounds checking can cause incomplete fix when similar checks are not propagated to related functions.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing overflow in one function by bounds checking can cause incomplete fix when similar checks are not propagated to related functions.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-190] → [CWE-693] Protection Mechanism Failure</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing refcount overflow by limited checks can cause protection mechanism failures in meta commands.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing refcount overflow by limited checks can cause protection mechanism failures in meta commands.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-190] → [CWE-703] Improper Check or Handling of Exceptional Conditions</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing memory allocation by using unsigned int can cause inadequate NULL checks when using standard allocators.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing memory allocation by using unsigned int can cause inadequate NULL checks when using standard allocators.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-190] → [CWE-704] Incorrect Type Conversion or Cast</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing overflow by using incorrect type conversion can cause range bypass issues.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing overflow by using incorrect type conversion can cause range bypass issues.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-190] → [CWE-758] Reliance on Undefined, Unspecified, or Implementation-Defined Behavior</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing integer overflow by using pointer arithmetic can cause reliance on undefined behavior.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing integer overflow by using pointer arithmetic can cause reliance on undefined behavior.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-190] → [CWE-775] Missing Release of Memory after Effective Lifetime</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing compilation overflow by limiting size can cause memory issues if parsing phase exceeds limits.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing compilation overflow by limiting size can cause memory issues if parsing phase exceeds limits.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-190] → [CWE-787] Out-of-bounds Write</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing crash by adding late bounds checks can cause use-after-set vulnerabilities leading to out-of-bounds writes.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing crash by adding late bounds checks can cause use-after-set vulnerabilities leading to out-of-bounds writes.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-190] → [CWE-840] Business Logic Errors</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing integer overflows by strict bounds checks can cause compatibility issues with valid file formats.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing integer overflows by strict bounds checks can cause compatibility issues with valid file formats.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-191] → [CWE-125] Out-of-bounds Read</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing negative length by setting to zero can cause out-of-bounds read due to missing length validation.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing negative length by setting to zero can cause out-of-bounds read due to missing length validation.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-193] → [CWE-119] Improper Restriction of Operations within the Bounds of a Memory Buffer</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing array length by altering loop bounds can cause undefined behavior due to out-of-bounds access.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing array length by altering loop bounds can cause undefined behavior due to out-of-bounds access.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-193] → [CWE-125] Out-of-bounds Read</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing buffer length validation by adding destination checks can cause source bounds issues.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing buffer length validation by adding destination checks can cause source bounds issues.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-193] → [CWE-665] Improper Initialization</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing buffer access by adding null-checks can cause similar unchecked patterns to remain in related code.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing buffer access by adding null-checks can cause similar unchecked patterns to remain in related code.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-20] → [CWE-128] Wrap-around Error</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing packet length handling by using unsigned integers can cause wrap-around issues with negative input values.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing packet length handling by using unsigned integers can cause wrap-around issues with negative input values.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-20] → [CWE-195] Signed to Unsigned Conversion Error</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing SSRF bypass by password validation can cause signedness conversion leading to validation bypass.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing SSRF bypass by password validation can cause signedness conversion leading to validation bypass.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-20] → [CWE-280] Improper Handling of Insufficiently Random Values</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing empty URL use by opaque URL can cause improper handling in cookie policies.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing empty URL use by opaque URL can cause improper handling in cookie policies.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-20] → [CWE-288] Authentication Bypass Using an Alternate Path or Channel</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing buffer overflow by arbitrary limits can cause incorrect key type detection leading to security issues.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing buffer overflow by arbitrary limits can cause incorrect key type detection leading to security issues.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-20] → [CWE-346] Origin Validation Error</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing DNS host key verification by downgrading keys can cause validation errors when trusted keys prompt verification.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing DNS host key verification by downgrading keys can cause validation errors when trusted keys prompt verification.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-20] → [CWE-347] Improper Verification of Cryptographic Signature</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing decryption length handling by switching to captured length can cause inadequate checks for incomplete payloads.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing decryption length handling by switching to captured length can cause inadequate checks for incomplete payloads.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-20] → [CWE-384] Session Fixation</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing Host header checks by ignoring Origin can allow cross-origin session fixation.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing Host header checks by ignoring Origin can allow cross-origin session fixation.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-20] → [CWE-401] Missing Release of Memory after Effective Lifetime</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing COOKIE-ECHO auth check by adding skb clone caused memory leaks on error paths.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing COOKIE-ECHO auth check by adding skb clone caused memory leaks on error paths.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-20] → [CWE-415] Double Free</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing NULL dereference by checking uaddr mismatch can lead to unchecked key matching causing dangling pointers.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing NULL dereference by checking uaddr mismatch can lead to unchecked key matching causing dangling pointers.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-20] → [CWE-457] Use of Uninitialized Variable</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing immediate return by goto can cause flow keys use before initialization.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing immediate return by goto can cause flow keys use before initialization.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-20] → [CWE-617] Reachable Assertion</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing negative-length asserts by blocking zero-length packets can cause assertion failures on valid inputs.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing negative-length asserts by blocking zero-length packets can cause assertion failures on valid inputs.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-20] → [CWE-628] Function Call with Incorrectly Specified Arguments</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing generated column handling by setting all bits can cause incorrect index coverage decisions.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing generated column handling by setting all bits can cause incorrect index coverage decisions.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-20] → [CWE-640] Weak Password Recovery Mechanism for Forgotten Password</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing site-for-cookies handling with empty URL can cause backend misconfigurations.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing site-for-cookies handling with empty URL can cause backend misconfigurations.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-20] → [CWE-668] Exposure of Resource to Wrong Sphere</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing quoting inconsistencies by patching argument formation can cause illegal path character vulnerabilities.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing quoting inconsistencies by patching argument formation can cause illegal path character vulnerabilities.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-20] → [CWE-691] Insufficient Control Flow Management</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing ring buffer overflow by sanitizing indices can cause asymmetric buffer operation checks.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing ring buffer overflow by sanitizing indices can cause asymmetric buffer operation checks.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-20] → [CWE-697] Incorrect Comparison</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing EOF checks by adding comparisons can cause incorrect variable checks leading to bypassed conditions.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing EOF checks by adding comparisons can cause incorrect variable checks leading to bypassed conditions.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-20] → [CWE-74] Improper Neutralization of Special Elements in Output Used by a Downstream Component (&#x27;Injection&#x27;)</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing URL validation by adding submodule URL checks can cause unchecked path inputs leading to injection vulnerabilities.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing URL validation by adding submodule URL checks can cause unchecked path inputs leading to injection vulnerabilities.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-20] → [CWE-749] Exposed Dangerous Method or Function</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing error by deferring layout_ops initialization can cause compliance violations due to missing mandatory protocol fields.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing error by deferring layout_ops initialization can cause compliance violations due to missing mandatory protocol fields.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-20] → [CWE-772] Missing Release of Resource after Effective Lifetime</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing data length checks by exception can cause resource leaks if resources are not cleaned prior to exception.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing data length checks by exception can cause resource leaks if resources are not cleaned prior to exception.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-20] → [CWE-824] Access of Uninitialized Pointer</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing pointer management by handling gstate can cause use-after-free issues due to invalidated pointers.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing pointer management by handling gstate can cause use-after-free issues due to invalidated pointers.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-20] → [CWE-834] Excessive Iteration</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing no-journal mode by bypassing orphan handling can cause infinite loops on orphaned inode cleanup.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing no-journal mode by bypassing orphan handling can cause infinite loops on orphaned inode cleanup.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-20] → [CWE-843] Access of Resource Using Incompatible Type (&#x27;Type Confusion&#x27;)</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing unserialize type checks by assuming array types can cause type confusion vulnerabilities.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing unserialize type checks by assuming array types can cause type confusion vulnerabilities.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-200] → [CWE-119] Improper Restriction of Operations within the Bounds of a Memory Buffer</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing map leaks by addressing access checks can cause unauthorized memory exposure via unchecked pointer arithmetic.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing map leaks by addressing access checks can cause unauthorized memory exposure via unchecked pointer arithmetic.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-200] → [CWE-123] Write-what-where Condition</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing uninitialized CS leaks by removing error recovery can cause writable kernel memory leak.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing uninitialized CS leaks by removing error recovery can cause writable kernel memory leak.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-200] → [CWE-125] Out-of-bounds Read</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing array index out-of-bounds by checking only logical length can cause buffer overreads in allocated segments.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing array index out-of-bounds by checking only logical length can cause buffer overreads in allocated segments.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-200] → [CWE-126] Buffer Over-read</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing infoleak by using nla_strlcpy can cause buffer over-read due to omitted NLA_HDRLEN bytes.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing infoleak by using nla_strlcpy can cause buffer over-read due to omitted NLA_HDRLEN bytes.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-200] → [CWE-20] Improper Input Validation</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing info leaks through extension checks can cause insufficient validation that allows unintended demuxer exploitation.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing info leaks through extension checks can cause insufficient validation that allows unintended demuxer exploitation.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-200] → [CWE-201] Insertion of Sensitive Information Into Log File</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing data exposure by resetting namelen can cause system state inconsistency issues when erroneously undone.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing data exposure by resetting namelen can cause system state inconsistency issues when erroneously undone.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-200] → [CWE-203] Observable Discrepancy</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing TCP session hijacking by global rate limiting can cause side-channel attack susceptibility.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing TCP session hijacking by global rate limiting can cause side-channel attack susceptibility.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-200] → [CWE-272] Least Privilege Violation</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing disk config by parameter reordering can cause privilege violations by omitting readonly settings.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing disk config by parameter reordering can cause privilege violations by omitting readonly settings.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-200] → [CWE-284] Improper Access Control</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing key serialization by adding assumption checks can cause misidentification of public keys as private keys.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing key serialization by adding assumption checks can cause misidentification of public keys as private keys.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-200] → [CWE-288] Authentication Bypass Using an Alternate Path or Channel</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing ACL adherence by ignoring config reloads can cause security settings bypass upon reload.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing ACL adherence by ignoring config reloads can cause security settings bypass upon reload.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-200] → [CWE-299] Improper Check for Certificate Revocation</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing IMAP PREAUTH MITM by requiring encryption can cause denial of service via legitimate tunnel connections.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing IMAP PREAUTH MITM by requiring encryption can cause denial of service via legitimate tunnel connections.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-200] → [CWE-362] Concurrent Execution using Shared Resource with Improper Synchronization</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P2</span>
              <span class="pattern-title">Fixing fragmentation by adjusting packet lengths can cause race conditions in concurrent packet handling.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing fragmentation by adjusting packet lengths can cause race conditions in concurrent packet handling.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-200] → [CWE-385] Covert Timing Channel</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing compiler optimizations by using volatile can cause new timing side-channels.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing compiler optimizations by using volatile can cause new timing side-channels.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-200] → [CWE-401] Improper Release of Memory Before Removing Last Reference (&#x27;Memory Leak&#x27;)</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing memory allocation by duplicate function calls can cause memory leaks.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing memory allocation by duplicate function calls can cause memory leaks.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-200] → [CWE-404] Improper Resource Shutdown or Release</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing memory leak by incorrectly using free() can cause improper cleanup of complex structures.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing memory leak by incorrectly using free() can cause improper cleanup of complex structures.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-200] → [CWE-416] Use After Free</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing memory leak by adding reference counting operations can cause use-after-free due to incorrect lifetime management.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing memory leak by adding reference counting operations can cause use-after-free due to incorrect lifetime management.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-200] → [CWE-476] NULL Pointer Dereference</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing info leak by initializing variables can cause NULL pointer dereference if NULL checks are removed.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing info leak by initializing variables can cause NULL pointer dereference if NULL checks are removed.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-200] → [CWE-693] Protection Mechanism Failure</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing buffer length checks by applying them to all records can cause legitimate responses to be rejected.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing buffer length checks by applying them to all records can cause legitimate responses to be rejected.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-200] → [CWE-705] Incorrect Update of Reference Count</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing info leak by zeroing msg_namelen can cause loss of valid address information.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing info leak by zeroing msg_namelen can cause loss of valid address information.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-200] → [CWE-710] Improper Adherence to Coding Standards</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing data exposure by ordering block writes can cause stale data exposure through improper metadata handling.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing data exposure by ordering block writes can cause stale data exposure through improper metadata handling.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-200] → [CWE-787] Out-of-bounds Write</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing ESN replay window validation by checking bitmap length can cause unchecked replay_window size in updates.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing ESN replay window validation by checking bitmap length can cause unchecked replay_window size in updates.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-200] → [CWE-79] Improper Neutralization of Input During Web Page Generation (&#x27;Cross-site Scripting&#x27;)</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing information leak by type checking can cause XSS through improper HTML string escaping.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing information leak by type checking can cause XSS through improper HTML string escaping.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-200] → [CWE-835] Loop with Unreachable Exit Condition (&#x27;Infinite Loop&#x27;)</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing data exposure by maintaining mount connections can cause looping issues with locked mounts.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing data exposure by maintaining mount connections can cause looping issues with locked mounts.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-200] → [CWE-908] Use of Uninitialized Variable</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing sscanf match count by strict checks can cause uninitialized variable use in partial matches.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing sscanf match count by strict checks can cause uninitialized variable use in partial matches.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-203] → [CWE-290] Authentication Bypass by Spoofing</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing STIBP enablement with legacy IBRS can cause bypass of cross-thread protection on certain platforms.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing STIBP enablement with legacy IBRS can cause bypass of cross-thread protection on certain platforms.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-203] → [CWE-327] Use of a Broken or Risky Cryptographic Algorithm</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing side-channel attacks by early unblinding can cause exposure of sensitive computations.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing side-channel attacks by early unblinding can cause exposure of sensitive computations.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-209] → [CWE-703] Improper Check or Handling of Exceptional Conditions</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing operator exposure by incorrect failure checks can cause hidden operators to be improperly handled.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing operator exposure by incorrect failure checks can cause hidden operators to be improperly handled.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-22] → [CWE-170] Improper Null Termination</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing path normalization by using strncmp can cause improper null termination in string handling.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing path normalization by using strncmp can cause improper null termination in string handling.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-22] → [CWE-20] Improper Input Validation</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing path sanitization by checking for &#x27;/&#x27; can cause bypass due to variable name misreference.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing path sanitization by checking for &#x27;/&#x27; can cause bypass due to variable name misreference.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-22] → [CWE-327] Use of a Broken or Risky Cryptographic Algorithm</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing capability negotiation by assuming complexity equals security can cause cryptographically weak defaults.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing capability negotiation by assuming complexity equals security can cause cryptographically weak defaults.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-22] → [CWE-59] Improper Link Resolution Before File Access (&#x27;Link Following&#x27;)</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing external symlink bypass by partial path check can cause incomplete protection against directory traversal.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing external symlink bypass by partial path check can cause incomplete protection against directory traversal.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-252] → [CWE-253] Incorrect Check of Function Return Value</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing unchecked ERR_PTR by adding IS_ERR can cause inconsistent error handling across multiple caller sites.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing unchecked ERR_PTR by adding IS_ERR can cause inconsistent error handling across multiple caller sites.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-252] → [CWE-787] Out-of-bounds Write</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing resource exhaustion by adding bounds checks can cause unchecked memory allocations elsewhere.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing resource exhaustion by adding bounds checks can cause unchecked memory allocations elsewhere.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-254] → [CWE-119] Improper Restriction of Operations within the Bounds of a Memory Buffer</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing CSRF token linkage by updating POST buffer handling can cause buffer overflows due to insufficient size checks.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing CSRF token linkage by updating POST buffer handling can cause buffer overflows due to insufficient size checks.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-254] → [CWE-22] Path Traversal</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing bind mount traversal by path connection checks can cause NFS traversal due to incorrect multi-root handling.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing bind mount traversal by path connection checks can cause NFS traversal due to incorrect multi-root handling.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-254] → [CWE-272] Least Privilege Violation</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing process state in daemon setup by changing directory early can cause privilege escalation risks.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing process state in daemon setup by changing directory early can cause privilege escalation risks.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-254] → [CWE-331] Insufficient Entropy</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing ASLR by using get_random_int can cause reduced entropy in address randomization.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing ASLR by using get_random_int can cause reduced entropy in address randomization.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-254] → [CWE-476] NULL Pointer Dereference</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing entry corruption by conditional node checks can cause NULL dereference crashes.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing entry corruption by conditional node checks can cause NULL dereference crashes.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-264] → [CWE-122] Heap-based Buffer Overflow</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing iframe DOM modifications by early bailouts can lead to unintended modification and use of DOM references.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing iframe DOM modifications by early bailouts can lead to unintended modification and use of DOM references.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-264] → [CWE-1325] Improper Handling of Speculative Execution Data</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing APICv state handling by omitting L1D controls can cause data leaks via speculative execution (L1TF).</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing APICv state handling by omitting L1D controls can cause data leaks via speculative execution (L1TF).</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-264] → [CWE-200] Exposure of Sensitive Information to an Unauthorized Actor</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing user pointer handling by unchecked sys_wait4() calls can cause information leaks.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing user pointer handling by unchecked sys_wait4() calls can cause information leaks.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-264] → [CWE-284] Improper Access Control</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing namespace access by LSM relabeling sequence can cause incorrect permissions with hidepid property.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing namespace access by LSM relabeling sequence can cause incorrect permissions with hidepid property.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-264] → [CWE-285] Improper Authorization</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing detached window navigation by setting null frames can cause cross-window script leakage vulnerabilities.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing detached window navigation by setting null frames can cause cross-window script leakage vulnerabilities.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-264] → [CWE-287] Improper Authentication</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing privilege lookup by unwarranted access restrictions can cause weakened system authentication controls.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing privilege lookup by unwarranted access restrictions can cause weakened system authentication controls.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-264] → [CWE-305] Insufficient Authorization</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing getEnvironment method access by adding C extension checks can cause authorization inconsistency in access control.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing getEnvironment method access by adding C extension checks can cause authorization inconsistency in access control.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-264] → [CWE-354] Improper Validation of Integrity Check Value</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing dangerous file download by removing bypass can cause unsafe defaults on verdict failures.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing dangerous file download by removing bypass can cause unsafe defaults on verdict failures.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-264] → [CWE-358] Improper Handling of Incomplete or Implemented Security Features</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing rule checks by strict rejection can cause improper handling of incomplete security features.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing rule checks by strict rejection can cause improper handling of incomplete security features.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-264] → [CWE-362] Race Condition</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing permissions/privilege vulnerabilities by adding access controls or locks can introduce race conditions when synchronization is incomplete.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing graphics backend initialization by adding &#x27;-vnc none&#x27; can cause crash-triggering race conditions during VNC setup.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-264] → [CWE-415] Double Free</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing sa_restorer clearing by incorrect signal handling can cause timer signal memory reference errors.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing sa_restorer clearing by incorrect signal handling can cause timer signal memory reference errors.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-264] → [CWE-457] Use of Uninitialized Variable</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing TLS segment validation by checking uninitialized fields can cause erroneous security checks.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing TLS segment validation by checking uninitialized fields can cause erroneous security checks.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-264] → [CWE-656] Incorrect Behavior Order: Early Validation of Complex Method Requests</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing navigation redirects with blank pages can cause user confusion due to missing error context.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing navigation redirects with blank pages can cause user confusion due to missing error context.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-264] → [CWE-672] Operation on a Resource after Expiration or Release</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing child containment checks by early bailouts can cause improper DOM node state validation during events.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing child containment checks by early bailouts can cause improper DOM node state validation during events.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-264] → [CWE-697] Incorrect Comparison</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing AArch32 state handling by incorrect exception vector logic can cause improper exception propagation.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing AArch32 state handling by incorrect exception vector logic can cause improper exception propagation.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-264] → [CWE-732] Incorrect Permission Assignment for Critical Resource</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing URL checks by using last committed URL can cause permission assignment errors in script execution.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing URL checks by using last committed URL can cause permission assignment errors in script execution.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-264] → [CWE-863] Incorrect Authorization</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing setattr permissions by using task creds can lead to incorrect privilege checks.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing setattr permissions by using task creds can lead to incorrect privilege checks.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-269] → [CWE-122] Heap-based Buffer Overflow</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing option parsing by whitelisting can cause heap overflow if bounds checks are incomplete.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing option parsing by whitelisting can cause heap overflow if bounds checks are incomplete.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-269] → [CWE-276] Incorrect Default Permissions</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing SGID inheritance by stripping SGID for non-members can cause improper permission checks with namespace mapping.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing SGID inheritance by stripping SGID for non-members can cause improper permission checks with namespace mapping.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-269] → [CWE-862] Missing Authorization</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing arbitrary command execution by disabling write can cause missing authorization checks when re-enabled.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing arbitrary command execution by disabling write can cause missing authorization checks when re-enabled.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-276] → [CWE-367] Time-of-check Time-of-use (TOCTOU) Race Condition</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing file permission security by chmod can cause race conditions if operation precedes successful file open.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing file permission security by chmod can cause race conditions if operation precedes successful file open.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-284] → [CWE-190] Integer Overflow or Wraparound</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing replay_window overflow by bmp_len validation can cause mismatched bmp_len leading to overflow.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing replay_window overflow by bmp_len validation can cause mismatched bmp_len leading to overflow.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-284] → [CWE-209] Information Exposure Through an Error Message</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing rename handling by backing inode checks can cause error code misinterpretation.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing rename handling by backing inode checks can cause error code misinterpretation.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-284] → [CWE-305] Authentication Bypass by Primary Weakness</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing authenticate connection persistence by closing connections can cause legitimate connections to fail unexpectedly.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing authenticate connection persistence by closing connections can cause legitimate connections to fail unexpectedly.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-284] → [CWE-327] Use of a Broken or Risky Cryptographic Algorithm</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing privilege-checking by queuing UD exceptions can cause incorrect exception handling in the guest.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing privilege-checking by queuing UD exceptions can cause incorrect exception handling in the guest.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-284] → [CWE-362] Concurrent Execution using Shared Resource with Improper Synchronization (&#x27;Race Condition&#x27;)</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing file path handling by removing locks can cause race conditions in prolog script execution.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing file path handling by removing locks can cause race conditions in prolog script execution.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-284] → [CWE-703] Improper Check or Handling of Exceptional Conditions</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing double tm_reclaim by checking MSR state can cause processes to start with invalid transactional state.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing double tm_reclaim by checking MSR state can cause processes to start with invalid transactional state.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-284] → [CWE-835] Loop with Unreachable Exit Condition (&#x27;Infinite Loop&#x27;)</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing timestamp delay handling by assuming maximum lateness can cause infinite loops under large timestamp differences.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing timestamp delay handling by assuming maximum lateness can cause infinite loops under large timestamp differences.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-287] → [CWE-188] Reliance on Data/Memory Layout</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing signature validation by using __le types can cause incorrect byte ordering on certain systems.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing signature validation by using __le types can cause incorrect byte ordering on certain systems.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-287] → [CWE-362] Concurrent Execution using Shared Resource with Improper Synchronization (&#x27;Race Condition&#x27;)</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing state handling by adjusting session state checks can cause concurrent socket ID use in multi-threaded contexts.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing state handling by adjusting session state checks can cause concurrent socket ID use in multi-threaded contexts.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-287] → [CWE-415] Double Free</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing crashes by adding RefPtr protectors can cause reference counting issues during deletion process.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing crashes by adding RefPtr protectors can cause reference counting issues during deletion process.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-287] → [CWE-472] External Control of Assumed-Immutable Web Parameter</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing session handling by using map find can cause improper parsing of cookie strings, allowing session hijacking.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing session handling by using map find can cause improper parsing of cookie strings, allowing session hijacking.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-287] → [CWE-476] NULL Pointer Dereference</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing credential reuse by comparing proxy credentials can cause NULL pointer dereference when credentials are missing.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing credential reuse by comparing proxy credentials can cause NULL pointer dereference when credentials are missing.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-287] → [CWE-665] Improper Initialization</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing flags initialization by setting them to zero can cause uninitialized flags in some error paths.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing flags initialization by setting them to zero can cause uninitialized flags in some error paths.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-287] → [CWE-667] Improper Locking</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing call number validation by enforcing strict checks can cause denial of service due to blocked protocol operations.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing call number validation by enforcing strict checks can cause denial of service due to blocked protocol operations.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-295] → [CWE-287] Improper Authentication</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing certificate and algorithm mismatch can cause incomplete authentication state tracking.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing certificate and algorithm mismatch can cause incomplete authentication state tracking.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-295] → [CWE-354] Improper Validation of Integrity Check Value</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing CRL lookups by using incorrect issuers can cause acceptance of invalid CRLs.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing CRL lookups by using incorrect issuers can cause acceptance of invalid CRLs.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-295] → [CWE-457] Use of Uninitialized Variable</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing incorrect return value checks can cause improper input initialization for validations.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing incorrect return value checks can cause improper input initialization for validations.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-310] → [CWE-208] Observable Timing Discrepancy</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing padding timing by constant-time checks can cause new timing side-channels due to MAC varying computations.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing padding timing by constant-time checks can cause new timing side-channels due to MAC varying computations.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-310] → [CWE-302] Improper Isolation of Critical System Resources</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing incomplete key handling by adding checks can cause ineffective key isolation, allowing NULL usage.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing incomplete key handling by adding checks can cause ineffective key isolation, allowing NULL usage.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-310] → [CWE-385] Covert Timing Channel</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing memory leaks by including duplicate extension checks can cause timing side-channel vulnerabilities.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing memory leaks by including duplicate extension checks can cause timing side-channel vulnerabilities.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-310] → [CWE-416] Use After Free</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing IPv6 packet handling by modifying np-&gt;opt can cause unsynchronized access leading to use-after-free vulnerabilities.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing IPv6 packet handling by modifying np-&gt;opt can cause unsynchronized access leading to use-after-free vulnerabilities.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-310] → [CWE-674] Uncontrolled Recursion</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing memory leak by implementing recursion can cause stack overflow.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing memory leak by implementing recursion can cause stack overflow.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-337] → [CWE-331] Insufficient Entropy</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing predictable scrambling tables by keyfile-based approach can cause insufficient entropy in shuffling process.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing predictable scrambling tables by keyfile-based approach can cause insufficient entropy in shuffling process.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-338] → [CWE-775] Missing Release of File Descriptor or Handle after Effective Lifetime</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing random number generation fallback by using open file descriptors can cause resource leaks.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing random number generation fallback by using open file descriptors can cause resource leaks.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-346] → [CWE-670] Always-Incorrect Control Flow Implementation</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing unicast source validation by removing reflect-filters can cause improper packet dropping logic for valid responses.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing unicast source validation by removing reflect-filters can cause improper packet dropping logic for valid responses.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-347] → [CWE-401] Missing Release of Memory after Effective Lifetime</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing PGP signature validation by early loop breaks can cause memory leaks when &#x27;selfsig&#x27; is not freed.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing PGP signature validation by early loop breaks can cause memory leaks when &#x27;selfsig&#x27; is not freed.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-347] → [CWE-841] Improper Enforcement of Behavioral Workflow</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing false negatives by validating established stream can cause inaccurate progress tracking when data is not inspected.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing false negatives by validating established stream can cause inaccurate progress tracking when data is not inspected.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-352] → [CWE-287] Improper Authentication</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing CSRF verification by URL substring checking can cause authorization to be bypassed.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing CSRF verification by URL substring checking can cause authorization to be bypassed.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-354] → [CWE-124] Buffer Underwrite (&#x27;Buffer Underflow&#x27;)</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing string length handling by using MAX(0, len) can cause buffer underflow on empty strings.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing string length handling by using MAX(0, len) can cause buffer underflow on empty strings.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-358] → [CWE-404] Improper Resource Shutdown or Release</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing UDP checksum validation by skipping on checksum errors can cause memory leaks with socket destruction.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing UDP checksum validation by skipping on checksum errors can cause memory leaks with socket destruction.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-362] → [CWE-119] Improper Restriction of Operations within the Bounds of a Memory Buffer</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing race conditions by extent reallocation can cause incorrect initialization state leading to potential data loss.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing race conditions by extent reallocation can cause incorrect initialization state leading to potential data loss.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-362] → [CWE-20] Improper Input Validation</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing livelock issue by aggressive fault trapping can cause improper validation of guest-controlled inputs.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing livelock issue by aggressive fault trapping can cause improper validation of guest-controlled inputs.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-362] → [CWE-200] Exposure of Sensitive Information to an Unauthorized Actor</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing race conditions by altering locking sequence can cause improper flag handling, leading to privacy leaks with expired RPA.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing race conditions by altering locking sequence can cause improper flag handling, leading to privacy leaks with expired RPA.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-362] → [CWE-366] Race Condition within a Thread</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing race condition by better locking can cause reference counting vulnerabilities due to atomic operations.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing race condition by better locking can cause reference counting vulnerabilities due to atomic operations.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-362] → [CWE-400] Uncontrolled Resource Consumption</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing unacknowledged automount requests by lstat() can cause indefinite hangs on unresponsive NFS servers.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing unacknowledged automount requests by lstat() can cause indefinite hangs on unresponsive NFS servers.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-362] → [CWE-662] Improper Synchronization</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing race condition by adding locking can cause subtler data race on field without proper synchronization.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing race condition by adding locking can cause subtler data race on field without proper synchronization.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-362] → [CWE-664] Improper Control of a Resource Through its Lifetime</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing race conditions by nested loops can cause re-entrancy vulnerabilities during shutdown.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing race conditions by nested loops can cause re-entrancy vulnerabilities during shutdown.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-362] → [CWE-664] Improper Synchronization</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P2</span>
              <span class="pattern-title">Fixing race condition by pointer checks can cause improper memory synchronization issues.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing race condition by pointer checks can cause improper memory synchronization issues.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-362] → [CWE-693] Protection Mechanism Failure</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing dynamic script MIME checks by assuming parsing prevents execution can cause inadequate error handling for parser-executed scripts.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing dynamic script MIME checks by assuming parsing prevents execution can cause inadequate error handling for parser-executed scripts.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-362] → [CWE-703] Improper Check or Handling of Exceptional Conditions</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing I/O with delalloc blocks by adding checks can cause misuse of cached mappings, leading to stale data writes.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing I/O with delalloc blocks by adding checks can cause misuse of cached mappings, leading to stale data writes.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-362] → [CWE-710] Improper Adjacency Handling</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing SYSENTER emulation by segment error recovery can cause uninitialized CS segment in kernel.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing SYSENTER emulation by segment error recovery can cause uninitialized CS segment in kernel.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-362] → [CWE-732] Incorrect Permission Assignment for Critical Resource</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing race conditions by overriding access permissions can cause incorrect permission assignments.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing race conditions by overriding access permissions can cause incorrect permission assignments.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-362] → [CWE-783] Operator Precedence Logic Error</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing race conditions by mutex locking can cause unintended logic errors in buffer operations.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing race conditions by mutex locking can cause unintended logic errors in buffer operations.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-362] → [CWE-787] Out-of-bounds Write</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing race conditions by using local variables can cause out-of-order accesses and result in memory corruption.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing race conditions by using local variables can cause out-of-order accesses and result in memory corruption.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-369] → [CWE-125] Out-of-bounds Read</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing division by zero by rearranging calculations can cause out-of-bounds reads for empty tables.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing division by zero by rearranging calculations can cause out-of-bounds reads for empty tables.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-369] → [CWE-401] Improper Release of Memory Before Removing Last Reference (&#x27;Memory Leak&#x27;)</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing buffer overflow by using max dimension can cause unnecessary memory allocation.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing buffer overflow by using max dimension can cause unnecessary memory allocation.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-369] → [CWE-697] Incorrect Comparison</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing zero denominator by strict version check can cause errors in handling valid version 1 indices.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing zero denominator by strict version check can cause errors in handling valid version 1 indices.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-388] → [CWE-682] Incorrect Calculation</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing error handling by changing return checks can cause successful operations to be misreported as errors.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing error handling by changing return checks can cause successful operations to be misreported as errors.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-399] → [CWE-119] Improper Restriction of Operations within the Bounds of a Memory Buffer</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing NULL dereference by adding NULL checks can cause uninitialized memory access when validating parameter data.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing NULL dereference by adding NULL checks can cause uninitialized memory access when validating parameter data.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-399] → [CWE-120] Buffer Copy without Checking Size of Input (&#x27;Classic Buffer Overflow&#x27;)</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing buffer length check by assuming zero length can cause improper buffer validation.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing buffer length check by assuming zero length can cause improper buffer validation.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-399] → [CWE-121] Stack-based Buffer Overflow</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing frame size checks by increasing limits can cause stack overflow from excessive buffer allocation.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing frame size checks by increasing limits can cause stack overflow from excessive buffer allocation.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-399] → [CWE-209] Information Exposure Through an Error Message</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing #DB interception by unconditionally setting DB_VECTOR can cause exposure of debugging information to guests.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing #DB interception by unconditionally setting DB_VECTOR can cause exposure of debugging information to guests.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-399] → [CWE-285] Improper Access Control</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing endless loop by adding EOF checks can cause premature termination and denial of service.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing endless loop by adding EOF checks can cause premature termination and denial of service.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-399] → [CWE-321] Use of Hard-coded Cryptographic Key</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing PMTU logic by altering path checks can cause bypass of intended PMTU restrictions.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing PMTU logic by altering path checks can cause bypass of intended PMTU restrictions.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-399] → [CWE-362] Race Condition</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing resource management with control flow/timing changes but incomplete synchronization causes races in concurrent operations.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing use-after-free by deferring mm access can cause race conditions in memory statistics reporting.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-399] → [CWE-390] Detection of Error Condition Without Action</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing infinite loop by zeroing offset can cause silent data loss in malformed structures.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing infinite loop by zeroing offset can cause silent data loss in malformed structures.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-399] → [CWE-401] Improper Release of Memory Before Removing Last Reference (&#x27;Memory Leak&#x27;)</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing image null-check by partial resource cleanup can cause memory leaks in unhandled code paths.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing image null-check by partial resource cleanup can cause memory leaks in unhandled code paths.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-399] → [CWE-479] Signal Handler Use of a Non-reentrant Function</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing DoS by moving negotiation to child can cause unsafe signal handling with non-reentrant function calls.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing DoS by moving negotiation to child can cause unsafe signal handling with non-reentrant function calls.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-399] → [CWE-590] Free of Memory not on the Heap</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing memory leak by calling free on memory not allocated by malloc can cause memory corruption.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing memory leak by calling free on memory not allocated by malloc can cause memory corruption.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-399] → [CWE-664] Improper Control of a Resource Through its Lifetime</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing CR4 preservation by adding branch for CR4 can cause improper CR3 resource management.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing CR4 preservation by adding branch for CR4 can cause improper CR3 resource management.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-399] → [CWE-668] Exposure of Resource to Wrong Sphere</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing MSR access bounds by narrowing can cause exposure of host resources to unauthorized access.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing MSR access bounds by narrowing can cause exposure of host resources to unauthorized access.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-399] → [CWE-693] Protection Mechanism Failure</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing EOF checking by using eof_reached directly can cause improper end-of-file condition handling.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing EOF checking by using eof_reached directly can cause improper end-of-file condition handling.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-399] → [CWE-770] Allocation of Resources Without Limits or Throttling</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing empty FIFO usage by buffering can cause memory overload with large PTS gaps.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing empty FIFO usage by buffering can cause memory overload with large PTS gaps.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-399] → [CWE-775] Missing Release of Resource after Effective Lifetime</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing memory leaks by calling DestroyImage can cause additional leaks when not consistent across all paths.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing memory leaks by calling DestroyImage can cause additional leaks when not consistent across all paths.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-399] → [CWE-824] Access of Uninitialized Pointer</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing endless loop by checking zero-length can cause improper memory offset, risking uninitialized access.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing endless loop by checking zero-length can cause improper memory offset, risking uninitialized access.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-399] → [CWE-835] Loop with Unreachable Exit Condition (&#x27;Infinite Loop&#x27;)</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing infinite loop by lenient length check can cause persistent unbounded iteration with varying input lengths.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing infinite loop by lenient length check can cause persistent unbounded iteration with varying input lengths.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-399] → [CWE-922] Insecure Storage of Sensitive Information</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing obsolete node sync by aggressive mask application can cause transition data loss affecting URL visibility.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing obsolete node sync by aggressive mask application can cause transition data loss affecting URL visibility.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-400] → [CWE-119] Improper Restriction of Operations within the Bounds of a Memory Buffer</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing dref memory leak by improper parsing can cause buffer overflows.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing dref memory leak by improper parsing can cause buffer overflows.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-400] → [CWE-1284] Improper Validation of Specified Quantity in Input</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing memory leak by handling &#x27;msg&#x27; cleanup can cause improper validation of TXQ_QUANTUM input values, leading to soft lockups.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing memory leak by handling &#x27;msg&#x27; cleanup can cause improper validation of TXQ_QUANTUM input values, leading to soft lockups.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-400] → [CWE-362] Concurrent Execution using Shared Resource with Improper Synchronization (&#x27;Race Condition&#x27;)</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing infinite loop by reversion can cause race conditions during updates to the scheduling entities list.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing infinite loop by reversion can cause race conditions during updates to the scheduling entities list.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-400] → [CWE-404] Improper Resource Shutdown or Release</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing memory leaks by calling v3d_job_put can cause improper cleanup of scheduler resources.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing memory leaks by calling v3d_job_put can cause improper cleanup of scheduler resources.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-400] → [CWE-459] Incomplete Cleanup</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing memory leaks by using kfree on DMA memory can cause improper memory release.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing memory leaks by using kfree on DMA memory can cause improper memory release.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-400] → [CWE-476] NULL Pointer Dereference</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing memory leaks by inadequate device handling can cause NULL pointer dereferences.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing memory leaks by inadequate device handling can cause NULL pointer dereferences.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-400] → [CWE-664] Improper Control of a Resource Through its Lifetime</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing memory leak by goto error handling can cause runtime PM imbalance due to missing counter decrement.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing memory leak by goto error handling can cause runtime PM imbalance due to missing counter decrement.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-400] → [CWE-665] Improper Initialization</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing memory leaks by conditional releases can cause incomplete handling when patterns are not uniformly applied.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing memory leaks by conditional releases can cause incomplete handling when patterns are not uniformly applied.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-400] → [CWE-707] Improper Neutralization</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing TLB timestamp handling by conditional skips can cause incomplete cleanup of page type states.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing TLB timestamp handling by conditional skips can cause incomplete cleanup of page type states.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-400] → [CWE-754] Improper Check for Unusual or Exceptional Conditions</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing buffer overflow by strict blob size checks can cause denial of service by rejecting valid bit-packed images.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing buffer overflow by strict blob size checks can cause denial of service by rejecting valid bit-packed images.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-400] → [CWE-775] Improper Neutralization of Hazardous Elements in a Comment</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing blob reading by breaking on EOF can cause resource leaks if file handles are not closed properly.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing blob reading by breaking on EOF can cause resource leaks if file handles are not closed properly.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-400] → [CWE-843] Access of Resource Using Incompatible Type (&#x27;Type Confusion&#x27;)</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing stack exhaustion by adjusting recursion to iteration can cause incorrect array manipulations leading to memory issues.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing stack exhaustion by adjusting recursion to iteration can cause incorrect array manipulations leading to memory issues.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-401] → [CWE-121] Stack-based Buffer Overflow</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing memory leak by omitting string boundary checks can cause buffer overflow.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing memory leak by omitting string boundary checks can cause buffer overflow.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-401] → [CWE-190] Integer Overflow or Wraparound</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing dimensional calculations by casting can cause integer overflows in size conversions.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing dimensional calculations by casting can cause integer overflows in size conversions.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-401] → [CWE-388] Improper Error Handling</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing memory leaks by nullifying error pointers can cause improper error handling and obscure error messages.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing memory leaks by nullifying error pointers can cause improper error handling and obscure error messages.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-401] → [CWE-415] Double Free</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing memory leaks by conditional NULL assignment can cause use-after-free or double-free vulnerabilities.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing memory leaks by conditional NULL assignment can cause use-after-free or double-free vulnerabilities.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-401] → [CWE-416] Use After Free</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing memory leaks by freeing old data can cause use-after-free if data is reused in certain modes.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing memory leaks by freeing old data can cause use-after-free if data is reused in certain modes.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-401] → [CWE-476] NULL Pointer Dereference</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing memory leaks by adding close calls can cause NULL pointer dereference when return paths aren&#x27;t properly null-checked.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing memory leaks by adding close calls can cause NULL pointer dereference when return paths aren&#x27;t properly null-checked.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-401] → [CWE-617] Reachable Assertion</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing constant_IV_size check by assert can cause reachable assertions in release builds.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing constant_IV_size check by assert can cause reachable assertions in release builds.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-401] → [CWE-787] Out-of-bounds Write</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing string handling by setting last char to 0 can cause buffer overflows.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing string handling by setting last char to 0 can cause buffer overflows.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-404] → [CWE-248] Uncaught Exception</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing assertion by adding fatal error logging can cause uncaught exception vulnerabilities leading to application termination.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing assertion by adding fatal error logging can cause uncaught exception vulnerabilities leading to application termination.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-404] → [CWE-362] Race Condition within a Thread</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing invalid function pointer by using dummy functions can cause race conditions in signal handling.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing invalid function pointer by using dummy functions can cause race conditions in signal handling.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-415] → [CWE-119] Improper Restriction of Operations within the Bounds of a Memory Buffer</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing PT_DYNAMIC segment by adding checks can cause inadequate bounds validation.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing PT_DYNAMIC segment by adding checks can cause inadequate bounds validation.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-415] → [CWE-120] Buffer Copy without Checking Size of Input (&#x27;Classic Buffer Overflow&#x27;)</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing buffer overflow by size increase with insufficient boundary checks can cause new overflow vulnerabilities.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing buffer overflow by size increase with insufficient boundary checks can cause new overflow vulnerabilities.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-415] → [CWE-20] Improper Input Validation</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing multiplication overflow by safe checks can cause issues due to neglected input validation.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing multiplication overflow by safe checks can cause issues due to neglected input validation.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-415] → [CWE-264] Improper Access Control</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing double-free by altering scope for properties can cause access control vulnerabilities via visibility bypass.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing double-free by altering scope for properties can cause access control vulnerabilities via visibility bypass.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-415] → [CWE-388] Improper Error Handling</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing function call results by checking return values can cause silent errors in buffer operations.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing function call results by checking return values can cause silent errors in buffer operations.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-415] → [CWE-763] Release of Invalid Pointer or Reference</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing double free by leaving wake bits can cause unauthorized wakeups.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing double free by leaving wake bits can cause unauthorized wakeups.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-415] → [CWE-775] Missing Release of Memory after Effective Lifetime</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing section decode error by returning errors can cause memory state corruption if state is not restored.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing section decode error by returning errors can cause memory state corruption if state is not restored.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-415] → [CWE-787] Out-of-bounds Write</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing double-free errors by managing deallocation can cause out-of-bounds accesses due to missing boundary checks.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing double-free errors by managing deallocation can cause out-of-bounds accesses due to missing boundary checks.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-415] → [CWE-835] Loop with Unreachable Exit Condition (&#x27;Infinite Loop&#x27;)</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing double free by modifying destruction logic can cause infinite loops due to incorrect search position handling.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing double free by modifying destruction logic can cause infinite loops due to incorrect search position handling.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-416] → [CWE-193] Off-by-one Error</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing out-of-bounds access by adding boundary checks can cause off-by-one errors when check order is incorrect.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing out-of-bounds access by adding boundary checks can cause off-by-one errors when check order is incorrect.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-416] → [CWE-200] Exposure of Sensitive Information to an Unauthorized Actor</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing GIF map fetching by altering disposal modes can cause information leakage across frames.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing GIF map fetching by altering disposal modes can cause information leakage across frames.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-416] → [CWE-367] Time-of-check Time-of-use (TOCTOU) Race Condition</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing race conditions by moving mutex_lock introduced its use in atomic contexts causing locking issues.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing race conditions by moving mutex_lock introduced its use in atomic contexts causing locking issues.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-416] → [CWE-399] Resource Management Errors</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing memory safety by orphaning can cause improper handling of zerocopy buffers leading to resource leaks.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing memory safety by orphaning can cause improper handling of zerocopy buffers leading to resource leaks.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-416] → [CWE-404] Improper Resource Shutdown or Release</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing race condition with mutexes can cause a kernel crash on handle client mismatch.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing race condition with mutexes can cause a kernel crash on handle client mismatch.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-416] → [CWE-476] NULL Pointer Dereference</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing UAF by removing reference list pop can cause memory leaks and NULL dereferences.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing UAF by removing reference list pop can cause memory leaks and NULL dereferences.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-416] → [CWE-502] Deserialization of Untrusted Data</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing use-after-free by checking undefined values can cause insecure deserialization due to improper object compatibility checks.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing use-after-free by checking undefined values can cause insecure deserialization due to improper object compatibility checks.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-416] → [CWE-640] Weak Password Recovery Mechanism for Forgotten Password</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing async callback handling by enforcing single-action caching can cause failure in validating multiple actions.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing async callback handling by enforcing single-action caching can cause failure in validating multiple actions.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-416] → [CWE-665] Improper Initialization</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing use-after-free by altering file operations sequence can cause incomplete initialization of file state.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing use-after-free by altering file operations sequence can cause incomplete initialization of file state.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-416] → [CWE-667] Improper Locking</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing use-after-free by returning error on NULL can cause deadlock if mutex is not properly unlocked.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing use-after-free by returning error on NULL can cause deadlock if mutex is not properly unlocked.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-416] → [CWE-668] Exposure of Resource to Wrong Sphere</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing activation logic without modal key setting can cause unintentional resource exposure.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing activation logic without modal key setting can cause unintentional resource exposure.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-416] → [CWE-690] Unchecked Return Value to NULL Pointer Dereference</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing out-of-bounds access by adding checks can cause unchecked operations on altered paths.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing out-of-bounds access by adding checks can cause unchecked operations on altered paths.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-416] → [CWE-691] Insufficient Control Flow Management</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing crash by initializing policy dump can cause ESN replay attribute validation bypass under certain flags.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing crash by initializing policy dump can cause ESN replay attribute validation bypass under certain flags.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-416] → [CWE-754] Improper Check for Unusual or Exceptional Conditions</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing use-after-free by removing functions can cause overly strict tile part ordering checks.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing use-after-free by removing functions can cause overly strict tile part ordering checks.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-416] → [CWE-783] Operator Precedence Logic Error</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing stack limit handling by inadequate operations can cause mismanagement of stack extension blocks.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing stack limit handling by inadequate operations can cause mismanagement of stack extension blocks.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-416] → [CWE-824] Access of Uninitialized Pointer</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing use-after-free by setting pointer to NULL can cause access of uninitialized pointer.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing use-after-free by setting pointer to NULL can cause access of uninitialized pointer.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-416] → [CWE-825] Expired Pointer Dereference</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing cross-namespace peeling off by adding a check can cause use-after-free in rhashtable walk.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing cross-namespace peeling off by adding a check can cause use-after-free in rhashtable walk.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-416] → [CWE-833] Deadlock</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing use-after-free by adding NULL assignment can cause deadlock in supply chain locking.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing use-after-free by adding NULL assignment can cause deadlock in supply chain locking.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-426] → [CWE-732] Incorrect Permission Assignment for Critical Resource</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing PKCS#11 path addition with realpath can cause path removal bypass without canonicalization.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing PKCS#11 path addition with realpath can cause path removal bypass without canonicalization.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-436] → [CWE-693] Protection Mechanism Failure</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing broken ACK field rejection by packet discard can cause evasion of stream detection.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing broken ACK field rejection by packet discard can cause evasion of stream detection.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-459] → [CWE-703] Improper Check or Handling of Exceptional Conditions</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing flush checks by considering PTE fields can cause improper merge logic handling.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing flush checks by considering PTE fields can cause improper merge logic handling.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-476] → [CWE-116] Improper Encoding or Escaping of Output</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing endpoint presence by checking static altsetting can cause driver misbinding due to incorrect setting verification.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing endpoint presence by checking static altsetting can cause driver misbinding due to incorrect setting verification.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-476] → [CWE-120] Buffer Copy without Checking Size of Input (&#x27;Classic Buffer Overflow&#x27;)</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing buffer parsing via minimum length checks can cause unchecked size adjustments to lead to overflows.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing buffer parsing via minimum length checks can cause unchecked size adjustments to lead to overflows.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-476] → [CWE-125] Out-of-bounds Read</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing buffer overflow checks by limiting max locations can cause buffer underflow when negative indices are unchecked.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing buffer overflow checks by limiting max locations can cause buffer underflow when negative indices are unchecked.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-476] → [CWE-129] Improper Validation of Array Index</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing null pointer dereference by adding checks can cause exposure to negative array index vulnerabilities.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing null pointer dereference by adding checks can cause exposure to negative array index vulnerabilities.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-476] → [CWE-193] Off-by-one Error</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing boundary cases by adjusting low pointers can cause incorrect handling of character heads.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing boundary cases by adjusting low pointers can cause incorrect handling of character heads.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-476] → [CWE-226] Sensitive Information Uncleared Before Release</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing cryptographic key alignment by using kzfree can cause sensitive data to remain uncleared.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing cryptographic key alignment by using kzfree can cause sensitive data to remain uncleared.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-476] → [CWE-303] Incorrect Implementation of Authentication Algorithm</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing encryption initiation by checking full SA establishment can cause improper rejection of valid encrypted notifications.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing encryption initiation by checking full SA establishment can cause improper rejection of valid encrypted notifications.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-476] → [CWE-305] Authentication Bypass by Primary Weakness</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing auth_user crash by checking presence can cause inconsistent authentication enforcement under different methods.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing auth_user crash by checking presence can cause inconsistent authentication enforcement under different methods.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-476] → [CWE-307] Improper Restriction of Security Mechanism</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing data presence by conditional export/import can cause unchecked key requirements, leading to improper operations.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing data presence by conditional export/import can cause unchecked key requirements, leading to improper operations.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-476] → [CWE-327] Use of a Broken or Risky Cryptographic Algorithm</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing key initialization order by using ECB mode can cause insecure encryption vulnerabilities.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing key initialization order by using ECB mode can cause insecure encryption vulnerabilities.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-476] → [CWE-362] Race Condition within a Thread</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing NULL dereference with checks/locks but incomplete synchronization (missing locks/improper locking) creates races under concurrency.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing negative key read by flag checks can cause race condition in key state access.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-476] → [CWE-362] Race Condition</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing NULL dereference with checks/locks but incomplete synchronization (missing locks/improper locking) creates races under concurrency.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing NPD by locking ax25_disconnect can cause race conditions with timer expiry.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-476] → [CWE-388] Improper Error Handling</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing NULL pointer dereference by adding validation can cause incorrect error context handling.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing NULL pointer dereference by adding validation can cause incorrect error context handling.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-476] → [CWE-398] Indicator of Poor Code Quality</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing NULL checks by simple returns can cause unallocated paths to remain unchecked.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing NULL checks by simple returns can cause unallocated paths to remain unchecked.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-476] → [CWE-399] Resource Management Errors</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing fragment memory accounting by recursive handling can cause incorrect skb ownership management.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing fragment memory accounting by recursive handling can cause incorrect skb ownership management.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-476] → [CWE-400] Uncontrolled Resource Consumption</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing UAF by unconditional timer stopping can cause session resource leaks.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing UAF by unconditional timer stopping can cause session resource leaks.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-476] → [CWE-457] Use of Uninitialized Variable</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing JP2 box cleanup by adjusting ops management can cause use of uninitialized data structures.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing JP2 box cleanup by adjusting ops management can cause use of uninitialized data structures.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-476] → [CWE-617] Reachable Assertion</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing profile handling by adding assertions can cause unexpected assertion failures.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing profile handling by adding assertions can cause unexpected assertion failures.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-476] → [CWE-664] Improper Control of a Resource Through its Lifetime</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing hash addition by conditional checks can cause inconsistent handling leading to stack manipulation issues.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing hash addition by conditional checks can cause inconsistent handling leading to stack manipulation issues.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-476] → [CWE-667] Improper Locking</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing invalid parsing by incorrect variable usage can cause undefined behavior due to uninitialized variable access.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing invalid parsing by incorrect variable usage can cause undefined behavior due to uninitialized variable access.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-476] → [CWE-690] Unchecked Return Value to NULL Pointer Dereference</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing null pointer dereference by adding checks can cause incorrect validation with operator misuse.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing null pointer dereference by adding checks can cause incorrect validation with operator misuse.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-476] → [CWE-693] Protection Mechanism Failure</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing palette handling by mode only checks can cause denial of service in valid files with palettes.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing palette handling by mode only checks can cause denial of service in valid files with palettes.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-476] → [CWE-703] Improper Check or Handling of Exceptional Conditions</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing absent error checks by null returns can cause insufficient error propagation.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing absent error checks by null returns can cause insufficient error propagation.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-476] → [CWE-754] Improper Check for Unusual or Exceptional Conditions</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing NULL dereference by type checks can cause improper handling of object initialization failures.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing NULL dereference by type checks can cause improper handling of object initialization failures.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-476] → [CWE-778] Insufficient Logging</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing crash by altering cookie checks can cause unintended log suppression, leading to insufficient security logging.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing crash by altering cookie checks can cause unintended log suppression, leading to insufficient security logging.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-476] → [CWE-787] Out-of-bounds Write</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing header colon checks by overly simplistic whitespace stripping can cause buffer overflow during header processing.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing header colon checks by overly simplistic whitespace stripping can cause buffer overflow during header processing.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-476] → [CWE-833] Deadlock</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing NULL dereference by changing registration order can cause deadlocks during concurrent disconnect and open operations.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing NULL dereference by changing registration order can cause deadlocks during concurrent disconnect and open operations.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-502] → [CWE-915] Improper Authorization</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing broken object cleanup by limiting allowed classes can cause bypass of nested class restrictions.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing broken object cleanup by limiting allowed classes can cause bypass of nested class restrictions.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-522] → [CWE-22] Improper Limitation of a Pathname to a Restricted Directory (&#x27;Path Traversal&#x27;)</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing upward path traversal by simple &#x27;../&#x27; removal can cause bypass via alternative traversal sequences.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing upward path traversal by simple &#x27;../&#x27; removal can cause bypass via alternative traversal sequences.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-532] → [CWE-436] Improper Interaction Between Multiple Errors</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing uninitialized stack bug by full ciphertext length check can cause incorrect replay detection.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing uninitialized stack bug by full ciphertext length check can cause incorrect replay detection.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-59] → [CWE-22] Improper Limitation of a Pathname to a Restricted Directory (&#x27;Path Traversal&#x27;)</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing symbolic link traversal by strict checks can cause path parsing weaknesses with non-normalized paths.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing symbolic link traversal by strict checks can cause path parsing weaknesses with non-normalized paths.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-59] → [CWE-362] Race Condition</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing link following by using file descriptors can introduce race conditions in permission checks.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing final file creation security by using O_EXCL can cause race conditions in path permission checks.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-59] → [CWE-362] Concurrent Execution using Shared Resource with Improper Synchronization (&#x27;Race Condition&#x27;)</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing link following by using file descriptors can introduce race conditions in permission checks.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing TOCTOU by using fd-based ops can cause unintended device access through non-symlink file openings.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-59] → [CWE-367] Time-of-check Time-of-use (TOCTOU) Race Condition</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing hardlink protection by pathname checks can cause race conditions during path resolution.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing hardlink protection by pathname checks can cause race conditions during path resolution.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-59] → [CWE-425] Direct Request (&#x27;Resource Exposure&#x27;)</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing symlink validation by ownership checks can cause exposure by skipping intermediate link validation.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing symlink validation by ownership checks can cause exposure by skipping intermediate link validation.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-59] → [CWE-703] Improper Check or Handling of Exceptional Conditions</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing symlink attack by using open/write can cause incomplete error handling for write failures.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing symlink attack by using open/write can cause incomplete error handling for write failures.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-59] → [CWE-732] Incorrect Permission Assignment for Critical Resource</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing ownership by chown can cause improper permission inheritance through umask.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing ownership by chown can cause improper permission inheritance through umask.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-59] → [CWE-775] Missing Release of File Descriptor or Handle after Effective Lifetime</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing symlink handling by tracking ownership can cause file descriptor leaks.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing symlink handling by tracking ownership can cause file descriptor leaks.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-59] → [CWE-787] Out-of-bounds Write</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing symlink following by assuming directories only can cause improper file type handling.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing symlink following by assuming directories only can cause improper file type handling.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-601] → [CWE-201] Information Exposure Through Sent Data</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing open redirects by hostname verification can cause improper handling of protocol-relative URLs.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing open redirects by hostname verification can cause improper handling of protocol-relative URLs.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-601] → [CWE-602] Client-Side Enforcement of Server-Side Security</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing open redirect by single validation step at target_link_uri can cause incomplete input validation.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing open redirect by single validation step at target_link_uri can cause incomplete input validation.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-611] → [CWE-284] Improper Access Control</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing external entity loading by directly adjusting parser options can cause improper access control to XML resources.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing external entity loading by directly adjusting parser options can cause improper access control to XML resources.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-617] → [CWE-120] Buffer Copy without Checking Size of Input (&#x27;Classic Buffer Overflow&#x27;)</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing bit parsing logic by looping individual bits can cause buffer overflow on malformed input.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing bit parsing logic by looping individual bits can cause buffer overflow on malformed input.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-617] → [CWE-125] Out-of-bounds Read</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing null subcontext cleanup can cause out-of-bounds read due to lacking header length checks.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing null subcontext cleanup can cause out-of-bounds read due to lacking header length checks.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-617] → [CWE-203] Observable Discrepancy</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing out-of-bounds IRQ handling by skipping BUG() can cause unintended exposure of cache states.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing out-of-bounds IRQ handling by skipping BUG() can cause unintended exposure of cache states.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-617] → [CWE-401] Improper Release of Memory Before Removing Last Reference (&#x27;Memory Leak&#x27;)</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing reachable assertion by throwing exceptions or adding error exits can cause memory leaks when cleanup code is bypassed in error paths.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing channel count errors by throwing exceptions can cause memory leaks due to skipped cleanup.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-617] → [CWE-670] Always-Incorrect Control Flow Implementation</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing wasm type validation by using default case can cause incorrect handling of invalid section IDs.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing wasm type validation by using default case can cause incorrect handling of invalid section IDs.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-617] → [CWE-672] Operation on a Resource after Expiration or Release</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing null pointer dereference by null checking can cause inconsistent cleanup leading to resource leaks.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing null pointer dereference by null checking can cause inconsistent cleanup leading to resource leaks.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-617] → [CWE-685] Function Call With Incorrect Number of Arguments</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing page reference counting by using unchecked allocations can cause incorrect memory usage and tracking.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing page reference counting by using unchecked allocations can cause incorrect memory usage and tracking.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-617] → [CWE-693] Protection Mechanism Failure</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing tensor validation by checking wrong inputs can cause unchecked non-scalar inputs.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing tensor validation by checking wrong inputs can cause unchecked non-scalar inputs.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-617] → [CWE-703] Improper Check or Handling of Exceptional Conditions</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing assertion handling by altering circuit initialization can cause cryptographic errors to go unchecked.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing assertion handling by altering circuit initialization can cause cryptographic errors to go unchecked.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-617] → [CWE-835] Loop with Unreachable Exit Condition (&#x27;Infinite Loop&#x27;)</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing label-length check by adding early returns can cause infinite loops with unchecked compression pointers.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing label-length check by adding early returns can cause infinite loops with unchecked compression pointers.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-665] → [CWE-367] Time-of-check Time-of-use (TOCTOU) Race Condition</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing uninitialized structure leaking by zeroing can cause TOCTOU issues when shared memory isn&#x27;t properly protected.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing uninitialized structure leaking by zeroing can cause TOCTOU issues when shared memory isn&#x27;t properly protected.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-665] → [CWE-704] Incorrect Type Conversion or Cast</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing geometry parsing by conditional value assignments can cause incorrect type handling when flags are unset.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing geometry parsing by conditional value assignments can cause incorrect type handling when flags are unset.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-665] → [CWE-710] Improper Adherence to Coding Standards</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing specific flag checks by addressing isolated instances can cause systemic discrepancies across related code segments.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing specific flag checks by addressing isolated instances can cause systemic discrepancies across related code segments.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-667] → [CWE-120] Buffer Copy without Checking Size of Input (&#x27;Classic Buffer Overflow&#x27;)</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing locking issues by global buffer removal can cause buffer overflow with unchecked user data handling.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing locking issues by global buffer removal can cause buffer overflow with unchecked user data handling.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-668] → [CWE-20] Improper Input Validation</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing namespace ambiguity by rejecting separator can cause denial of service via legitimate URI rejections.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing namespace ambiguity by rejecting separator can cause denial of service via legitimate URI rejections.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-668] → [CWE-272] Least Privilege Violation</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing shadow-linear mappings by changing safety check location can cause privilege escalation through improper alias detection.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing shadow-linear mappings by changing safety check location can cause privilege escalation through improper alias detection.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-670] → [CWE-764] Multiple Locks of a Critical Resource</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing foreign page mapping with domain checks can cause resource locking issues due to missing reference counts.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing foreign page mapping with domain checks can cause resource locking issues due to missing reference counts.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-672] → [CWE-401] Improper Release of Memory Before Removing Last Reference</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing resource lifecycle issues by adding cleanup can leave other allocations unreleased.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing memory leaks through conditional checks can cause incomplete release of all dynamic allocations.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-672] → [CWE-401] Improper Release of Memory Before Removing Last Reference (&#x27;Memory Leak&#x27;)</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing resource lifecycle issues by adding cleanup can leave other allocations unreleased.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing memory cleanup by simplifying free call can cause resource leakage when not all allocations are handled.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-674] → [CWE-275] Permission Issues in Directory Traversal</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing directory recursion by switching to queue traversal can cause access permission issues in directory removal.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing directory recursion by switching to queue traversal can cause access permission issues in directory removal.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-674] → [CWE-400] Uncontrolled Resource Consumption</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing recursion depth checks by omitting time limits can cause excessive resource consumption.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing recursion depth checks by omitting time limits can cause excessive resource consumption.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-674] → [CWE-829] Inclusion of Functionality from Untrusted Control Sphere</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing infinite recursion by using markings can cause excessive permissions granting to document sections.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing infinite recursion by using markings can cause excessive permissions granting to document sections.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-682] → [CWE-476] NULL Pointer Dereference</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing font limit handling by assuming correct font restores can cause crashes due to missing restoration for system fonts.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing font limit handling by assuming correct font restores can cause crashes due to missing restoration for system fonts.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-697] → [CWE-369] Divide By Zero</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing timescale validation by checking non-zero inputs can cause a division by zero when results are not verified.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing timescale validation by checking non-zero inputs can cause a division by zero when results are not verified.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-703] → [CWE-125] Out-of-bounds Read</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing capability validation by relaxed size checks can cause buffer overreads.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing capability validation by relaxed size checks can cause buffer overreads.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-703] → [CWE-126] Buffer Over-read</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing recursion depth by upper bound checks can cause buffer over-reads with incorrect decrement handling.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing recursion depth by upper bound checks can cause buffer over-reads with incorrect decrement handling.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-703] → [CWE-197] Numeric Truncation Error</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing buffer overflow by checking multiplication overflow can cause data truncation errors.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing buffer overflow by checking multiplication overflow can cause data truncation errors.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-703] → [CWE-20] Improper Input Validation</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing input validation by adding shape and dimension checks can cause missing critical validation leading to segfaults.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing input validation by adding shape and dimension checks can cause missing critical validation leading to segfaults.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-703] → [CWE-330] Use of Insufficiently Random Values</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing freelist duplicates by weak PRNG use can cause predictable random sequences.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing freelist duplicates by weak PRNG use can cause predictable random sequences.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-703] → [CWE-404] Improper Resource Shutdown or Release</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing keyring ref leak by key_put omission can cause further keyring leaks in unhandled error paths.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing keyring ref leak by key_put omission can cause further keyring leaks in unhandled error paths.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-703] → [CWE-561] Dead Code</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing counter underflow by reverting open coding can cause dead code paths in resource cleanup.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing counter underflow by reverting open coding can cause dead code paths in resource cleanup.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-703] → [CWE-672] Operation on a Resource after Expiration or Release</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing NULL dereference by adding transport checks can cause stale connection objects during loopback handling.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing NULL dereference by adding transport checks can cause stale connection objects during loopback handling.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-703] → [CWE-787] Out-of-bounds Write</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing heap-buffer-overflow by adjusting extent calculation can cause insufficient accounting for image size and samples.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing heap-buffer-overflow by adjusting extent calculation can cause insufficient accounting for image size and samples.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-704] → [CWE-119] Improper Restriction of Operations within the Bounds of a Memory Buffer</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing stack underflow by incorrect stack checks can cause improper stack manipulation vulnerabilities.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing stack underflow by incorrect stack checks can cause improper stack manipulation vulnerabilities.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-73] → [CWE-670] Always-Incorrect Control Flow Implementation</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing LFI by overly broad blocking can cause valid inputs to be improperly rejected.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing LFI by overly broad blocking can cause valid inputs to be improperly rejected.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-732] → [CWE-367] Time-of-check Time-of-use (TOCTOU) Race Condition</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing parallel execution by mandatory file locks can cause race conditions with special-case files.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing parallel execution by mandatory file locks can cause race conditions with special-case files.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-74] → [CWE-338] Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing session ID generation with predictable entropy sources can cause session fixation risks.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing session ID generation with predictable entropy sources can cause session fixation risks.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-74] → [CWE-416] Use After Free</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing null byte truncation by allowing unchecked resource use can cause use-after-free conditions.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing null byte truncation by allowing unchecked resource use can cause use-after-free conditions.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-74] → [CWE-78] Improper Neutralization of Special Elements used in an OS Command (&#x27;OS Command Injection&#x27;)</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing buffer overflow by enlarging buffers can cause command injection due to improper input handling.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing buffer overflow by enlarging buffers can cause command injection due to improper input handling.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-754] → [CWE-200] Exposure of Sensitive Information to an Unauthorized Actor</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing kernel member integrity by clearing fields can cause sensitive information leakage through user-space interactions.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing kernel member integrity by clearing fields can cause sensitive information leakage through user-space interactions.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-755] → [CWE-823] Use of Out-of-range Pointer Offset</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing infinite recursion by offset zero returns can cause unsafe pointer offset calculations.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing infinite recursion by offset zero returns can cause unsafe pointer offset calculations.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-755] → [CWE-862] Missing Authorization</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing ownership by adding pull method can cause unauthorized access on session bus fallback.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing ownership by adding pull method can cause unauthorized access on session bus fallback.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-763] → [CWE-416] Use After Free</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing pointer initialization by setting it to NULL in one path missed a similar pattern in another path, causing UAF.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing pointer initialization by setting it to NULL in one path missed a similar pattern in another path, causing UAF.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-763] → [CWE-666] Operation on Resource in Wrong Phase of Lifetime</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing node-accounting assumptions by direct invocation can cause incorrect resource lifetime assumptions and leaks.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing node-accounting assumptions by direct invocation can cause incorrect resource lifetime assumptions and leaks.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-77] → [CWE-116] Improper Encoding or Escaping of Output</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing command validation by character substitution can cause improper validation due to encoding mismatches.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing command validation by character substitution can cause improper validation due to encoding mismatches.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-77] → [CWE-22] Improper Limitation of a Pathname to a Restricted Directory (&#x27;Path Traversal&#x27;)</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing insecure path expansion by removing wordexp can cause path traversal issues on MinGW systems.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing insecure path expansion by removing wordexp can cause path traversal issues on MinGW systems.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-77] → [CWE-703] Improper Check or Handling of Exceptional Conditions</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing command-line option validation by adding static checks can cause incorrect control flow for command validation.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing command-line option validation by adding static checks can cause incorrect control flow for command validation.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-770] → [CWE-404] Improper Resource Shutdown or Release</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing resource handling with inconsistent deallocation can cause memory leaks in error paths.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing resource handling with inconsistent deallocation can cause memory leaks in error paths.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-770] → [CWE-617] Reachable Assertion</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing data size validation by array access can cause unchecked dimension assertions.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing data size validation by array access can cause unchecked dimension assertions.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-770] → [CWE-693] Protection Mechanism Failure</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing buffer overflow by strict size checks can cause denial of service by rejecting valid input as corrupted.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing buffer overflow by strict size checks can cause denial of service by rejecting valid input as corrupted.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-770] → [CWE-772] Missing Release of Resource after Effective Lifetime</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing null pointer dereference by adding NULL check can cause resource leaks if resource is not released.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing null pointer dereference by adding NULL check can cause resource leaks if resource is not released.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-772] → [CWE-120] Buffer Copy without Checking Size of Input (&#x27;Classic Buffer Overflow&#x27;)</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing memory leaks by destroying malformed profiles can cause buffer overflows via improper header initialization.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing memory leaks by destroying malformed profiles can cause buffer overflows via improper header initialization.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-772] → [CWE-252] Unchecked Return Value</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing object initialization failure by freeing memory can cause unchecked return value leading to misuse of invalid IDs.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing object initialization failure by freeing memory can cause unchecked return value leading to misuse of invalid IDs.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-772] → [CWE-388] Improper Error Handling</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing wiretap errors by incorrect description use can cause misleading error messages in output contexts.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing wiretap errors by incorrect description use can cause misleading error messages in output contexts.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-772] → [CWE-401] Memory Leak</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing resource leaks with partial cleanup can cause memory leaks when other allocated resources remain unreleased.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing resource leaks by deallocating selectively can cause other resources to remain unreleased.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-772] → [CWE-404] Improper Resource Shutdown or Release</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing selective memory leaks by partial cleanup can cause incomplete resource release on error paths.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing selective memory leaks by partial cleanup can cause incomplete resource release on error paths.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-772] → [CWE-415] Double Free</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing memory leaks by early resource deallocation can cause double-frees when resources are freed later unconditionally.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing memory leaks by early resource deallocation can cause double-frees when resources are freed later unconditionally.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-772] → [CWE-457] Use of Uninitialized Variable</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing memory management by conditional destruction can cause use of uninitialized variables when checks are incomplete.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing memory management by conditional destruction can cause use of uninitialized variables when checks are incomplete.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-772] → [CWE-617] Reachable Assertion</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing earlier memory leaks without checking maxpasses can cause reachable assertion failure.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing earlier memory leaks without checking maxpasses can cause reachable assertion failure.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-772] → [CWE-665] Improper Initialization</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing memory leaks by freeing memory can cause improper validation of image data lengths.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing memory leaks by freeing memory can cause improper validation of image data lengths.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-772] → [CWE-754] Improper Check for Unusual or Exceptional Conditions</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing unsupported image depths by exception throwing can cause valid depths to be misclassified, leading to denial of service.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing unsupported image depths by exception throwing can cause valid depths to be misclassified, leading to denial of service.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-772] → [CWE-824] Access of Uninitialized Pointer</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing image handling by reordering destruction logic can cause use of an uninitialized pointer.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing image handling by reordering destruction logic can cause use of an uninitialized pointer.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-772] → [CWE-835] Loop with Unreachable Exit Condition (&#x27;Infinite Loop&#x27;)</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing page reference count by early return can cause infinite loop when max_append_sectors is zero.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing page reference count by early return can cause infinite loop when max_append_sectors is zero.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-78] → [CWE-120] Buffer Copy without Checking Size of Input (&#x27;Classic Buffer Overflow&#x27;)</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing popen() use by replacing with string concatenation can cause buffer overflow when username components are too long.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing popen() use by replacing with string concatenation can cause buffer overflow when username components are too long.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-787] → [CWE-121] Stack-based Buffer Overflow</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing memory leaks by switching to stack allocation can cause stack overflows with insufficient buffer sizes.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing memory leaks by switching to stack allocation can cause stack overflows with insufficient buffer sizes.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-787] → [CWE-129] Improper Validation of Array Index</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing XML recursion depth by imposing limits can cause array access underflow when depth checks are incomplete.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing XML recursion depth by imposing limits can cause array access underflow when depth checks are incomplete.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-787] → [CWE-191] Integer Underflow (Wrap or Wraparound)</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing buffer bounds check by subtracting one can cause integer underflow and buffer overflow risk.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing buffer bounds check by subtracting one can cause integer underflow and buffer overflow risk.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-787] → [CWE-20] Improper Input Validation</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing out-of-bounds by adjusting lmax check positions can allow improper MTU value to bypass validation.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing out-of-bounds by adjusting lmax check positions can allow improper MTU value to bypass validation.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-787] → [CWE-200] Exposure of Sensitive Information to an Unauthorized Actor</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing enclave boundary checking by using output_len can cause incorrect memory range validation.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing enclave boundary checking by using output_len can cause incorrect memory range validation.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-787] → [CWE-346] Origin Validation Error</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing out-of-array access by partial chunk validation can cause mishandling of invalid sequences.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing out-of-array access by partial chunk validation can cause mishandling of invalid sequences.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-787] → [CWE-362] Concurrent Execution using Shared Resource with Improper Synchronization (&#x27;Race Condition&#x27;)</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing buffer overflow by using static buffers can cause race conditions in multi-threaded environments.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing buffer overflow by using static buffers can cause race conditions in multi-threaded environments.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-787] → [CWE-401] Improper Release of Memory Before Removing Last Reference (&#x27;Memory Leak&#x27;)</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing buffer overflow with memory allocation/management but omitting cleanup/deallocation on error paths causes memory leaks.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing buffer overflows by removing redundant functions can cause memory leaks when original allocations are not freed.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-787] → [CWE-416] Use After Free</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing IV_size check by introducing load_needed flag without cleanup can cause use after free vulnerabilities.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing IV_size check by introducing load_needed flag without cleanup can cause use after free vulnerabilities.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-787] → [CWE-477] Use of Obsolete or Unsafe Function</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing memory corruption by changing parsing logic can cause locale-dependent parsing failures.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing memory corruption by changing parsing logic can cause locale-dependent parsing failures.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-787] → [CWE-617] Reachable Assertion</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing packet caplen checks by adding assertions can cause exploitable program crashes with malformed inputs.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing packet caplen checks by adding assertions can cause exploitable program crashes with malformed inputs.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-787] → [CWE-662] Improper Synchronization</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing message parsing by static scoping critical flags can cause concurrent handling inconsistencies.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing message parsing by static scoping critical flags can cause concurrent handling inconsistencies.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-787] → [CWE-665] Improper Initialization</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing op stack management by switching to ref_stack_pop() can cause improper stack size checks before operations.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing op stack management by switching to ref_stack_pop() can cause improper stack size checks before operations.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-787] → [CWE-669] Incorrect Resource Transfer Between Spheres</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing VM stack handling by altering stack logic can cause incorrect stack positioning of return values, risking memory corruption.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing VM stack handling by altering stack logic can cause incorrect stack positioning of return values, risking memory corruption.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-787] → [CWE-682] Incorrect Calculation</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing compression size calculation by manual formula can cause buffer overflow due to miscalculated size.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing compression size calculation by manual formula can cause buffer overflow due to miscalculated size.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-787] → [CWE-685] Function Call With Incorrect Number of Arguments</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing pointer arithmetic overflow by condition checks can cause incorrect pointer arithmetic in 32-bit platforms.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing pointer arithmetic overflow by condition checks can cause incorrect pointer arithmetic in 32-bit platforms.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-787] → [CWE-697] Incorrect Comparison</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing LZW code size validation by adding a &#x27;first&#x27; flag can cause false positives in file validation.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing LZW code size validation by adding a &#x27;first&#x27; flag can cause false positives in file validation.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-787] → [CWE-703] Improper Check or Handling of Exceptional Conditions</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing EOS checks can cause decoder state errors to be ignored, leading to incorrect assumptions.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing EOS checks can cause decoder state errors to be ignored, leading to incorrect assumptions.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-787] → [CWE-704] Incorrect Type Conversion or Cast</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing UUID box parsing by improper type usage can cause memory corruption.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing UUID box parsing by improper type usage can cause memory corruption.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-787] → [CWE-770] Allocation of Resources Without Limits or Throttling</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing buffer overflow by enlarging allocations can cause unbounded memory allocation.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing buffer overflow by enlarging allocations can cause unbounded memory allocation.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-787] → [CWE-788] Access of Memory Location After End of Buffer</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing Juniper header buffer overflow by length checks can cause removal of essential bounds checks.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing Juniper header buffer overflow by length checks can cause removal of essential bounds checks.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-787] → [CWE-805] Buffer Access with Incorrect Length Value</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing buffer allocation size by increasing multiplier can cause incorrect length issues in later size calculations.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing buffer allocation size by increasing multiplier can cause incorrect length issues in later size calculations.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-787] → [CWE-823] Use of Out-of-range Pointer Offset</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing link handling by page validation post-access can cause use of invalid indexes before checks.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing link handling by page validation post-access can cause use of invalid indexes before checks.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-787] → [CWE-828] Inherited Risk of Incorrect Implementation</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing buffer allocation by adjusting size parameters can cause incorrect signature verification.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing buffer allocation by adjusting size parameters can cause incorrect signature verification.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-787] → [CWE-835] Loop with Unreachable Exit Condition (&#x27;Infinite Loop&#x27;)</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing integer overflow by overflow checks can cause unsafe environment management leading to memory corruption.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing integer overflow by overflow checks can cause unsafe environment management leading to memory corruption.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-787] → [CWE-838] Inappropriate Access Control</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing state transition by conditional updates can allow unintended class type usage in restricted operations.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing state transition by conditional updates can allow unintended class type usage in restricted operations.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-79] → [CWE-330] Use of Insufficiently Random Values</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing DNS entry validation by using a simple counter for query IDs can cause predictability, facilitating DNS cache poisoning.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing DNS entry validation by using a simple counter for query IDs can cause predictability, facilitating DNS cache poisoning.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-79] → [CWE-672] Operation on a Resource after Expiration or Release</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing session restore logic by using &#x27;IsOffTheRecord&#x27; can cause mishandling of guest profiles.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing session restore logic by using &#x27;IsOffTheRecord&#x27; can cause mishandling of guest profiles.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-79] → [CWE-703] Improper Check or Handling of Exceptional Conditions</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing bindings API usage by switching ScriptState methods can cause improper V8 exception propagation.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing bindings API usage by switching ScriptState methods can cause improper V8 exception propagation.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-79] → [CWE-80] Improper Neutralization of Script-Related HTML Tags in a Web Page (Basic XSS)</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing JavaScript injection by filtering single quotes can cause incomplete neutralization allowing alternate injection vectors.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing JavaScript injection by filtering single quotes can cause incomplete neutralization allowing alternate injection vectors.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-805] → [CWE-125] Out-of-bounds Read</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing out-of-bounds reads by using hardcoded boundary check can cause incorrect offset calculations leading to buffer over-read vulnerabilities.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing out-of-bounds reads by using hardcoded boundary check can cause incorrect offset calculations leading to buffer over-read vulnerabilities.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-834] → [CWE-120] Buffer Copy without Checking Size of Input (&#x27;Classic Buffer Overflow&#x27;)</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing offset advancement logic by incorrect condition can cause buffer overflows.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing offset advancement logic by incorrect condition can cause buffer overflows.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-834] → [CWE-252] Unchecked Return Value</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing EOF check by adding return can cause unchecked return value errors in similar functions.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing EOF check by adding return can cause unchecked return value errors in similar functions.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-834] → [CWE-401] Improper Release of Memory Before Removing Last Reference (&#x27;Memory Leak&#x27;)</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing excessive iteration by adding validation can introduce memory leaks through early returns.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing DoS issues by adding invalid data checks can cause memory leaks if duplicate allocations aren&#x27;t managed.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-834] → [CWE-401] Missing Release of Memory after Effective Lifetime</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing excessive iteration by adding validation can introduce memory leaks through early returns.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing DoS by adding EOF checks can cause memory leaks due to premature return without cleanup.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-834] → [CWE-416] Use After Free</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing EOF issue by storing MIME types can cause use-after-free in subsequent codec data reads.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing EOF issue by storing MIME types can cause use-after-free in subsequent codec data reads.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-834] → [CWE-697] Incorrect Comparison</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing buffer overflow by using floating-point comparison can cause precision-related security check bypass.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing buffer overflow by using floating-point comparison can cause precision-related security check bypass.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-834] → [CWE-824] Access of Uninitialized Pointer</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing EOF handling by status checks can cause memory corruption due to continued processing of invalid data.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing EOF handling by status checks can cause memory corruption due to continued processing of invalid data.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-834] → [CWE-835] Infinite Loop</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing infinite iteration by adding break conditions can result in partial loop termination fixes leaving similar patterns vulnerable.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing infinite iteration by adding break conditions can result in partial loop termination fixes leaving similar patterns vulnerable.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-835] → [CWE-119] Improper Restriction of Operations within the Bounds of a Memory Buffer</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing infinite loops by adding return checks can cause misaligned GFN handling to overlook boundary conditions.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing infinite loops by adding return checks can cause misaligned GFN handling to overlook boundary conditions.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-835] → [CWE-121] Stack-based Buffer Overflow</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing FTYP atom bounds by insufficient checks can cause buffer overflows due to header size underestimation.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing FTYP atom bounds by insufficient checks can cause buffer overflows due to header size underestimation.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-835] → [CWE-362] Concurrent Execution using Shared Resource with Improper Synchronization (&#x27;Race Condition&#x27;)</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing infinite loops by altering socket handling can cause race conditions in socket state transitions.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing infinite loops by altering socket handling can cause race conditions in socket state transitions.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-835] → [CWE-401] Improper Release of Memory Before Removing Last Reference (&#x27;Memory Leak&#x27;)</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing dimension settings by altering control flow can cause memory leaks on new exit paths.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing dimension settings by altering control flow can cause memory leaks on new exit paths.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-835] → [CWE-665] Improper Initialization</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing infinite loops by setting length to 0 can cause improper packet handling in reassembly.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing infinite loops by setting length to 0 can cause improper packet handling in reassembly.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-835] → [CWE-764] Multiple Locking Issues</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing infinite loops by setting high retry counts can cause prolonged system hangs.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing infinite loops by setting high retry counts can cause prolonged system hangs.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-835] → [CWE-770] Allocation of Resources Without Limits or Throttling</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing infinite recursion by setting a high nesting limit can cause stack exhaustion.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing infinite recursion by setting a high nesting limit can cause stack exhaustion.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-835] → [CWE-780] Use of Incorrectly-Resolved Name or Reference</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing infinite loop risk by adding count checks can cause incomplete resolution in code paths calling other vulnerable functions.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing infinite loop risk by adding count checks can cause incomplete resolution in code paths calling other vulnerable functions.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-843] → [CWE-476] NULL Pointer Dereference</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing speculative execution mitigations by adjusting pointer indexes can cause pointer dereference errors.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing speculative execution mitigations by adjusting pointer indexes can cause pointer dereference errors.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-862] → [CWE-306] Missing Authentication for Critical Function</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing privilege check for creation by requiring namespace ownership can cause missing privilege check for deletions.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing privilege check for creation by requiring namespace ownership can cause missing privilege check for deletions.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-862] → [CWE-840] Business Logic Errors</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing discoverable persistence by constant check can cause faulty state handling.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing discoverable persistence by constant check can cause faulty state handling.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-862] → [CWE-863] Incorrect Authorization</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing lack of Write permission check by adding Write checks can cause Link permission bypass.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing lack of Write permission check by adding Write checks can cause Link permission bypass.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-89] → [CWE-287] Improper Authentication</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing SQL injection by parameter sanitization can cause improper authentication handling.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing SQL injection by parameter sanitization can cause improper authentication handling.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-89] → [CWE-642] External Control of Critical State Data</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing SQL injection by partial input validation can lead to unescaped critical fields being vulnerable.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing SQL injection by partial input validation can lead to unescaped critical fields being vulnerable.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-908] → [CWE-129] Improper Validation of Array Index</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing integer overflow by adjusting boundary checks can cause out-of-bounds reads when checks are insufficient.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing integer overflow by adjusting boundary checks can cause out-of-bounds reads when checks are insufficient.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-908] → [CWE-362] Concurrent Execution using Shared Resource with Improper Synchronization (&#x27;Race Condition&#x27;)</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing file type handling by returning ENOTDIR can cause race conditions in file verification.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing file type handling by returning ENOTDIR can cause race conditions in file verification.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-91] → [CWE-116] Improper Encoding or Escaping of Output</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing shell injection with incomplete sanitization can cause quoting inconsistencies leading to command injection.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing shell injection with incomplete sanitization can cause quoting inconsistencies leading to command injection.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-91] → [CWE-159] Improper Handling of Insufficient Whitelisting</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing command injection via insufficient blacklisting can cause new injections via unlisted characters.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing command injection via insufficient blacklisting can cause new injections via unlisted characters.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-913] → [CWE-476] NULL Pointer Dereference</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing isolate restriction by pointer access can cause null pointer dereference vulnerabilities.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing isolate restriction by pointer access can cause null pointer dereference vulnerabilities.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-918] → [CWE-922] Insecure Storage of Sensitive Information</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing port parsing by rejecting tailing characters can cause broken valid URL patterns with path components.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing port parsing by rejecting tailing characters can cause broken valid URL patterns with path components.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-94] → [CWE-502] Deserialization of Untrusted Data</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing use-after-free by special interface checks can cause class deserialization privilege violations.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing use-after-free by special interface checks can cause class deserialization privilege violations.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-94] → [CWE-835] Loop with Unreachable Exit Condition (&#x27;Infinite Loop&#x27;)</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing deprecated quit methods by improper loop exit handling can cause infinite loops preventing shutdown.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing deprecated quit methods by improper loop exit handling can cause infinite loops preventing shutdown.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-94] → [CWE-843] Access of Resource Using Incompatible Type (&#x27;Type Confusion&#x27;)</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing instruction length with simple check can cause incorrect handling of multi-page instruction boundaries.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing instruction length with simple check can cause incorrect handling of multi-page instruction boundaries.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
      <section class="pair">
        <div class="pair-title">
          <h2>[CWE-94] → [CWE-943] Improper Neutralization of Special Elements in Data Query Logic</h2>
          <div class="meta">
            <span class="stats">Patterns: 1 • Records: 1</span>
          </div>
        </div>
        <div class="patterns">
          
          <div class="pattern-card">
            <div class="pattern-header">
              <span class="badge">P1</span>
              <span class="pattern-title">Fixing environment variable exposure by using --env-fd can cause incomplete input neutralization for caller-supplied variables.</span>
              <span class="pattern-count">(1 records)</span>
            </div>
            <details>
              <summary>Examples</summary>
              <ul class="examples">
                <li>Fixing environment variable exposure by using --env-fd can cause incomplete input neutralization for caller-supplied variables.</li>
              </ul>
            </details>
          </div>
        
        </div>
      </section>
    
  
  <div class="footer">Sorted by record count (most instances first) • Patterns grouped by CWE transition pairs</div>
</main>
<script>
  const search = document.getElementById('search');
  const pairs = Array.from(document.querySelectorAll('section.pair'));
  function normalize(s) { return (s || '').toLowerCase(); }
  function itemText(el) { return normalize(el.innerText); }
  function onSearch() {
    const q = normalize(search.value);
    pairs.forEach(p => {
      const text = itemText(p);
      p.classList.toggle('hidden', q && !text.includes(q));
    });
  }
  search.addEventListener('input', onSearch);
</script>
</body>
</html>
